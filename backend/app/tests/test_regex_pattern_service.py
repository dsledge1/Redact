"""
Comprehensive unit tests for RegexPatternService.

Tests cover predefined patterns, custom pattern support, validation,
confidence scoring, pattern combination, and performance optimization.
"""

import unittest
from unittest.mock import Mock, patch, MagicMock
import re
from collections import defaultdict

# Import the service and related classes
from ..services.regex_pattern_service import (
    RegexPatternService, PatternType, PatternDefinition, PatternMatch,
    ValidationMode, MatchMode, measure_processing_time
)
from ..utils.text_processing import text_normalizer


class TestRegexPatternService(unittest.TestCase):
    """Test cases for RegexPatternService."""
    
    def setUp(self):
        """Set up test environment."""
        self.service = RegexPatternService(enable_caching=True, cache_size=100)
        
        # Sample text pages for testing
        self.sample_pages = [
            {
                'page_number': 1,
                'text': 'John Doe SSN: 123-45-6789 Phone: (555) 123-4567 Email: john@example.com'
            },
            {
                'page_number': 2, 
                'text': 'Credit Card: 4111-1111-1111-1111 Date: 12/25/2023 IP: 192.168.1.1'
            },
            {
                'page_number': 3,
                'text': 'Account: 1234567890 Routing: 021000021 URL: https://example.com'
            }
        ]
    
    def test_initialization(self):
        """Test service initialization."""
        service = RegexPatternService()
        
        self.assertTrue(service.enable_caching)
        self.assertEqual(service.cache_size, 1000)  # Default cache size
        self.assertIsInstance(service.predefined_patterns, dict)
        self.assertIsInstance(service.custom_patterns, dict)
        self.assertIsInstance(service.match_statistics, dict)
        
        # Verify predefined patterns were loaded
        self.assertGreater(len(service.predefined_patterns), 0)
        self.assertIn('ssn_standard', service.predefined_patterns)
        self.assertIn('email_standard', service.predefined_patterns)
    \n    def test_predefined_patterns_initialization(self):\n        \"\"\"Test that predefined patterns are properly initialized.\"\"\"\n        patterns = self.service.predefined_patterns\n        \n        # Test SSN patterns\n        self.assertIn('ssn_standard', patterns)\n        self.assertIn('ssn_no_dashes', patterns)\n        self.assertIn('ssn_spaces', patterns)\n        \n        ssn_pattern = patterns['ssn_standard']\n        self.assertEqual(ssn_pattern.pattern_type, PatternType.SSN)\n        self.assertIn('123-45-6789', ssn_pattern.examples)\n        \n        # Test credit card patterns\n        self.assertIn('cc_visa', patterns)\n        self.assertIn('cc_mastercard', patterns)\n        self.assertIn('cc_amex', patterns)\n        \n        visa_pattern = patterns['cc_visa']\n        self.assertEqual(visa_pattern.pattern_type, PatternType.CREDIT_CARD)\n        self.assertEqual(visa_pattern.validation_mode, ValidationMode.LUHN_CHECK)\n        \n        # Test other pattern types\n        self.assertIn('email_standard', patterns)\n        self.assertIn('phone_us_standard', patterns)\n        self.assertIn('ipv4', patterns)\n        self.assertIn('url_http', patterns)\n        self.assertIn('date_mm_dd_yyyy', patterns)\n    \n    def test_find_pattern_matches_basic(self):\n        \"\"\"Test basic pattern matching functionality.\"\"\"\n        matches = self.service.find_pattern_matches(\n            text_pages=self.sample_pages,\n            pattern_types=[PatternType.SSN, PatternType.EMAIL],\n            enable_validation=True,\n            confidence_threshold=0.7\n        )\n        \n        self.assertIsInstance(matches, list)\n        \n        # Should find SSN and email matches\n        ssn_matches = [m for m in matches if m.pattern_type == PatternType.SSN]\n        email_matches = [m for m in matches if m.pattern_type == PatternType.EMAIL]\n        \n        self.assertGreater(len(ssn_matches), 0)\n        self.assertGreater(len(email_matches), 0)\n        \n        # Verify match properties\n        ssn_match = ssn_matches[0]\n        self.assertEqual(ssn_match.matched_text, '123-45-6789')\n        self.assertEqual(ssn_match.page_number, 1)\n        self.assertGreater(ssn_match.confidence_score, 0.7)\n        self.assertIn('SSN:', ssn_match.context)\n        \n        email_match = email_matches[0]\n        self.assertEqual(email_match.matched_text, 'john@example.com')\n        self.assertEqual(email_match.page_number, 1)\n    \n    def test_find_pattern_matches_credit_cards(self):\n        \"\"\"Test credit card pattern matching with Luhn validation.\"\"\"\n        matches = self.service.find_pattern_matches(\n            text_pages=self.sample_pages,\n            pattern_types=[PatternType.CREDIT_CARD],\n            enable_validation=True,\n            confidence_threshold=0.5\n        )\n        \n        credit_card_matches = [m for m in matches if m.pattern_type == PatternType.CREDIT_CARD]\n        self.assertGreater(len(credit_card_matches), 0)\n        \n        cc_match = credit_card_matches[0]\n        self.assertEqual(cc_match.matched_text, '4111-1111-1111-1111')\n        self.assertEqual(cc_match.page_number, 2)\n        \n        # Verify Luhn validation was applied\n        self.assertTrue(cc_match.validation_passed)\n        self.assertIn('luhn_valid', cc_match.validation_details)\n        self.assertTrue(cc_match.validation_details['luhn_valid'])\n    \n    def test_find_pattern_matches_phone_numbers(self):\n        \"\"\"Test phone number pattern matching.\"\"\"\n        matches = self.service.find_pattern_matches(\n            text_pages=self.sample_pages,\n            pattern_types=[PatternType.PHONE],\n            enable_validation=False,\n            confidence_threshold=0.6\n        )\n        \n        phone_matches = [m for m in matches if m.pattern_type == PatternType.PHONE]\n        self.assertGreater(len(phone_matches), 0)\n        \n        phone_match = phone_matches[0]\n        self.assertEqual(phone_match.matched_text, '(555) 123-4567')\n        self.assertEqual(phone_match.page_number, 1)\n    \n    def test_find_pattern_matches_specific_patterns(self):\n        \"\"\"Test pattern matching with specific pattern names.\"\"\"\n        matches = self.service.find_pattern_matches(\n            text_pages=self.sample_pages,\n            pattern_names=['ssn_standard', 'email_standard'],\n            enable_validation=True,\n            confidence_threshold=0.5\n        )\n        \n        pattern_names = [m.pattern_name for m in matches]\n        self.assertIn('SSN Standard Format', [m.pattern_name for m in matches])\n        self.assertIn('Email Address', [m.pattern_name for m in matches])\n        \n        # Should not find other patterns\n        credit_matches = [m for m in matches if m.pattern_type == PatternType.CREDIT_CARD]\n        self.assertEqual(len(credit_matches), 0)\n    \n    def test_luhn_validation(self):\n        \"\"\"Test Luhn algorithm validation.\"\"\"\n        validation_details = {}\n        \n        # Test valid credit card number\n        is_valid, details = self.service._validate_luhn('4111111111111111', validation_details)\n        self.assertTrue(is_valid)\n        self.assertIn('luhn_valid', details)\n        self.assertTrue(details['luhn_valid'])\n        \n        # Test invalid credit card number\n        validation_details = {}\n        is_valid, details = self.service._validate_luhn('4111111111111112', validation_details)\n        self.assertFalse(is_valid)\n        self.assertFalse(details['luhn_valid'])\n        \n        # Test with dashes and spaces\n        validation_details = {}\n        is_valid, details = self.service._validate_luhn('4111-1111-1111-1111', validation_details)\n        self.assertTrue(is_valid)\n        \n        # Test invalid format\n        validation_details = {}\n        is_valid, details = self.service._validate_luhn('invalid', validation_details)\n        self.assertFalse(is_valid)\n        self.assertIn('luhn_error', details)\n    \n    def test_routing_number_validation(self):\n        \"\"\"Test US bank routing number validation.\"\"\"\n        # Test valid routing numbers\n        self.assertTrue(self.service._validate_routing_number('021000021'))\n        self.assertTrue(self.service._validate_routing_number('011000015'))\n        \n        # Test invalid routing numbers\n        self.assertFalse(self.service._validate_routing_number('123456789'))\n        self.assertFalse(self.service._validate_routing_number('12345678'))  # Wrong length\n        self.assertFalse(self.service._validate_routing_number('0210000210'))  # Wrong length\n        \n        # Test with non-digits\n        self.assertFalse(self.service._validate_routing_number('02100002a'))\n    \n    def test_context_relevance_analysis(self):\n        \"\"\"Test context relevance analysis for different pattern types.\"\"\"\n        # Test SSN context\n        ssn_boost = self.service._analyze_context_relevance(\n            'Employee social security number: 123-45-6789 for tax purposes',\n            PatternType.SSN\n        )\n        self.assertGreater(ssn_boost, 0)\n        \n        # Test credit card context\n        cc_boost = self.service._analyze_context_relevance(\n            'Payment with credit card number 4111-1111-1111-1111',\n            PatternType.CREDIT_CARD\n        )\n        self.assertGreater(cc_boost, 0)\n        \n        # Test irrelevant context\n        irrelevant_boost = self.service._analyze_context_relevance(\n            'Page 123 figure reference 45-67-89 table footnote',\n            PatternType.SSN\n        )\n        self.assertLessEqual(irrelevant_boost, 0)\n        \n        # Test email context\n        email_boost = self.service._analyze_context_relevance(\n            'Please send email to john@example.com for contact',\n            PatternType.EMAIL\n        )\n        self.assertGreater(email_boost, 0)\n    \n    def test_add_custom_pattern(self):\n        \"\"\"Test adding custom patterns.\"\"\"\n        # Add valid custom pattern\n        success = self.service.add_custom_pattern(\n            name='custom_id',\n            pattern=r'\\bID-\\d{6}\\b',\n            description='Custom ID pattern',\n            pattern_type=PatternType.CUSTOM,\n            examples=['ID-123456', 'ID-987654']\n        )\n        \n        self.assertTrue(success)\n        self.assertIn('custom_id', self.service.custom_patterns)\n        \n        custom_pattern = self.service.custom_patterns['custom_id']\n        self.assertEqual(custom_pattern.name, 'custom_id')\n        self.assertEqual(custom_pattern.pattern, r'\\bID-\\d{6}\\b')\n        self.assertEqual(custom_pattern.pattern_type, PatternType.CUSTOM)\n        \n        # Test invalid pattern\n        success = self.service.add_custom_pattern(\n            name='invalid_pattern',\n            pattern='[invalid regex',  # Unclosed bracket\n            description='Invalid pattern',\n            pattern_type=PatternType.CUSTOM\n        )\n        \n        self.assertFalse(success)\n        self.assertNotIn('invalid_pattern', self.service.custom_patterns)\n    \n    def test_remove_custom_pattern(self):\n        \"\"\"Test removing custom patterns.\"\"\"\n        # Add a pattern first\n        self.service.add_custom_pattern(\n            name='temp_pattern',\n            pattern=r'\\bTEMP-\\d{3}\\b',\n            description='Temporary pattern',\n            pattern_type=PatternType.CUSTOM\n        )\n        \n        self.assertIn('temp_pattern', self.service.custom_patterns)\n        \n        # Remove the pattern\n        success = self.service.remove_custom_pattern('temp_pattern')\n        self.assertTrue(success)\n        self.assertNotIn('temp_pattern', self.service.custom_patterns)\n        \n        # Try to remove non-existent pattern\n        success = self.service.remove_custom_pattern('non_existent')\n        self.assertFalse(success)\n    \n    def test_pattern_testing(self):\n        \"\"\"Test pattern testing functionality.\"\"\"\n        test_strings = [\n            'Valid SSN: 123-45-6789',\n            'Invalid: 123-456-7890',\n            'No match here',\n            'Another valid: 987-65-4321'\n        ]\n        \n        result = self.service.test_pattern(\n            pattern=r'\\b\\d{3}-\\d{2}-\\d{4}\\b',\n            test_strings=test_strings\n        )\n        \n        self.assertTrue(result['valid_pattern'])\n        self.assertEqual(len(result['test_results']), 4)\n        \n        # Check first test result\n        first_result = result['test_results'][0]\n        self.assertEqual(first_result['test_string'], 'Valid SSN: 123-45-6789')\n        self.assertEqual(first_result['match_count'], 1)\n        self.assertEqual(first_result['matches'][0]['matched_text'], '123-45-6789')\n        \n        # Check result with no matches\n        no_match_result = result['test_results'][2]\n        self.assertEqual(no_match_result['match_count'], 0)\n        self.assertEqual(len(no_match_result['matches']), 0)\n        \n        # Test invalid pattern\n        invalid_result = self.service.test_pattern(\n            pattern='[invalid',\n            test_strings=['test']\n        )\n        \n        self.assertFalse(invalid_result['valid_pattern'])\n        self.assertIn('error', invalid_result)\n    \n    def test_confidence_scoring(self):\n        \"\"\"Test confidence scoring for pattern matches.\"\"\"\n        # Create test pattern with confidence boost\n        pattern_def = PatternDefinition(\n            name='Test Pattern',\n            pattern=r'\\bTEST-\\d{3}\\b',\n            description='Test pattern with boost',\n            pattern_type=PatternType.CUSTOM,\n            confidence_boost=0.1\n        )\n        \n        # Test with good context\n        confidence = self.service._calculate_pattern_confidence(\n            matched_text='TEST-123',\n            pattern_def=pattern_def,\n            validation_passed=True,\n            context='Test ID: TEST-123 for verification'\n        )\n        \n        self.assertGreater(confidence, 0.8)  # Should be high due to validation and boost\n        \n        # Test with poor context\n        poor_confidence = self.service._calculate_pattern_confidence(\n            matched_text='TEST-123',\n            pattern_def=pattern_def,\n            validation_passed=False,\n            context='Random text TEST-123 noise'\n        )\n        \n        self.assertLess(poor_confidence, confidence)  # Should be lower due to failed validation\n    \n    def test_pattern_compilation_caching(self):\n        \"\"\"Test pattern compilation caching.\"\"\"\n        pattern_def = PatternDefinition(\n            name='Cache Test',\n            pattern=r'\\bCACHE-\\d{3}\\b',\n            description='Cache test pattern',\n            pattern_type=PatternType.CUSTOM,\n            match_mode=MatchMode.CASE_INSENSITIVE\n        )\n        \n        # First call should compile pattern\n        compiled1 = self.service._get_compiled_pattern('cache_test', pattern_def)\n        self.assertIsInstance(compiled1, re.Pattern)\n        \n        # Second call should use cached version\n        compiled2 = self.service._get_compiled_pattern('cache_test', pattern_def)\n        self.assertIs(compiled1, compiled2)  # Should be the same object\n        \n        # Check cache contains the pattern\n        cache_key = 'cache_test_case_insensitive'\n        self.assertIn(cache_key, self.service._compiled_patterns)\n    \n    def test_pattern_match_validation_modes(self):\n        \"\"\"Test different validation modes.\"\"\"\n        # Test NONE validation\n        none_pattern = PatternDefinition(\n            name='No Validation',\n            pattern=r'\\bNO-VAL-\\d{3}\\b',\n            description='No validation pattern',\n            pattern_type=PatternType.CUSTOM,\n            validation_mode=ValidationMode.NONE\n        )\n        \n        valid, details = self.service._validate_pattern_match('NO-VAL-123', none_pattern)\n        self.assertTrue(valid)\n        self.assertEqual(details['method'], 'none')\n        \n        # Test BASIC validation\n        basic_pattern = PatternDefinition(\n            name='Basic Validation',\n            pattern=r'\\bBASIC-\\d{3}\\b',\n            description='Basic validation pattern',\n            pattern_type=PatternType.CUSTOM,\n            validation_mode=ValidationMode.BASIC\n        )\n        \n        valid, details = self.service._validate_pattern_match('BASIC-456', basic_pattern)\n        self.assertTrue(valid)\n        self.assertEqual(details['method'], 'basic')\n        \n        # Test ADVANCED validation with custom validator\n        def custom_validator(text):\n            return text.endswith('999')\n        \n        advanced_pattern = PatternDefinition(\n            name='Advanced Validation',\n            pattern=r'\\bADV-\\d{3}\\b',\n            description='Advanced validation pattern',\n            pattern_type=PatternType.CUSTOM,\n            validation_mode=ValidationMode.ADVANCED,\n            custom_validator=custom_validator\n        )\n        \n        # Should pass validation\n        valid, details = self.service._validate_pattern_match('ADV-999', advanced_pattern)\n        self.assertTrue(valid)\n        self.assertTrue(details['custom_validation'])\n        \n        # Should fail validation\n        valid, details = self.service._validate_pattern_match('ADV-123', advanced_pattern)\n        self.assertFalse(valid)\n    \n    def test_match_mode_handling(self):\n        \"\"\"Test different match modes.\"\"\"\n        # Create patterns with different match modes\n        case_sensitive = PatternDefinition(\n            name='Case Sensitive',\n            pattern=r'\\bTEST\\b',\n            description='Case sensitive test',\n            pattern_type=PatternType.CUSTOM,\n            match_mode=MatchMode.CASE_SENSITIVE\n        )\n        \n        case_insensitive = PatternDefinition(\n            name='Case Insensitive',\n            pattern=r'\\bTEST\\b',\n            description='Case insensitive test',\n            pattern_type=PatternType.CUSTOM,\n            match_mode=MatchMode.CASE_INSENSITIVE\n        )\n        \n        # Test case sensitive compilation\n        cs_compiled = self.service._get_compiled_pattern('cs_test', case_sensitive)\n        self.assertEqual(cs_compiled.flags & re.IGNORECASE, 0)\n        \n        # Test case insensitive compilation\n        ci_compiled = self.service._get_compiled_pattern('ci_test', case_insensitive)\n        self.assertNotEqual(ci_compiled.flags & re.IGNORECASE, 0)\n    \n    def test_context_extraction(self):\n        \"\"\"Test context extraction around matches.\"\"\"\n        long_text = (\n            \"This is a very long piece of text that contains sensitive information \"\n            \"like SSN 123-45-6789 which should be detected with proper context. \"\n            \"The context should include surrounding words for better understanding.\"\n        )\n        \n        context = self.service._get_pattern_context('123-45-6789', long_text, context_chars=50)\n        \n        self.assertIn('123-45-6789', context)\n        self.assertIn('SSN', context)\n        self.assertTrue(context.startswith('...'))\n        self.assertTrue(context.endswith('...'))\n        self.assertLessEqual(len(context), 150)  # Should be limited by context_chars\n    \n    def test_statistics_collection(self):\n        \"\"\"Test statistics collection and reporting.\"\"\"\n        # Perform some pattern matching to generate statistics\n        self.service.find_pattern_matches(\n            text_pages=self.sample_pages,\n            pattern_types=[PatternType.SSN, PatternType.EMAIL, PatternType.CREDIT_CARD],\n            enable_validation=True\n        )\n        \n        stats = self.service.get_pattern_statistics()\n        \n        self.assertIn('total_searches', stats)\n        self.assertIn('total_matches', stats)\n        self.assertIn('pattern_usage', stats)\n        self.assertIn('pattern_type_distribution', stats)\n        self.assertIn('compiled_patterns_cached', stats)\n        self.assertIn('custom_patterns_count', stats)\n        self.assertIn('predefined_patterns_count', stats)\n        \n        self.assertGreater(stats['total_searches'], 0)\n        self.assertGreater(stats['total_matches'], 0)\n        self.assertGreater(stats['predefined_patterns_count'], 0)\n    \n    def test_available_patterns_info(self):\n        \"\"\"Test getting available patterns information.\"\"\"\n        # Add a custom pattern first\n        self.service.add_custom_pattern(\n            name='test_custom',\n            pattern=r'\\bCUST-\\d{3}\\b',\n            description='Test custom pattern',\n            pattern_type=PatternType.CUSTOM\n        )\n        \n        patterns_info = self.service.get_available_patterns()\n        \n        self.assertIsInstance(patterns_info, dict)\n        self.assertIn('ssn_standard', patterns_info)\n        self.assertIn('test_custom', patterns_info)\n        \n        # Check predefined pattern info\n        ssn_info = patterns_info['ssn_standard']\n        self.assertEqual(ssn_info['pattern_type'], 'ssn')\n        self.assertFalse(ssn_info['is_custom'])\n        self.assertIn('examples', ssn_info)\n        \n        # Check custom pattern info\n        custom_info = patterns_info['test_custom']\n        self.assertEqual(custom_info['pattern_type'], 'custom')\n        self.assertTrue(custom_info['is_custom'])\n    \n    def test_cache_management(self):\n        \"\"\"Test cache management functionality.\"\"\"\n        # Add some entries to cache\n        self.service._compiled_patterns['test_key1'] = re.compile(r'test')\n        self.service._compiled_patterns['test_key2'] = re.compile(r'test2')\n        \n        self.assertEqual(len(self.service._compiled_patterns), 2)\n        \n        # Clear cache\n        self.service.clear_cache()\n        \n        self.assertEqual(len(self.service._compiled_patterns), 0)\n        self.assertEqual(len(self.service._pattern_cache), 0)\n    \n    def test_pattern_error_handling(self):\n        \"\"\"Test error handling in pattern operations.\"\"\"\n        # Test with invalid regex in predefined patterns (should not crash)\n        try:\n            matches = self.service.find_pattern_matches(\n                text_pages=[{'page_number': 1, 'text': 'test'}],\n                pattern_types=[PatternType.SSN]\n            )\n            # Should complete without error\n            self.assertIsInstance(matches, list)\n        except Exception as e:\n            self.fail(f\"Pattern matching should handle errors gracefully: {e}\")\n        \n        # Test pattern compilation error handling\n        with self.assertRaises(re.error):\n            self.service._get_compiled_pattern('invalid', PatternDefinition(\n                name='Invalid',\n                pattern='[unclosed',\n                description='Invalid pattern',\n                pattern_type=PatternType.CUSTOM\n            ))\n    \n    def test_confidence_threshold_filtering(self):\n        \"\"\"Test filtering matches by confidence threshold.\"\"\"\n        # Test with high confidence threshold\n        high_threshold_matches = self.service.find_pattern_matches(\n            text_pages=self.sample_pages,\n            pattern_types=[PatternType.SSN, PatternType.EMAIL],\n            confidence_threshold=0.95\n        )\n        \n        # Test with low confidence threshold\n        low_threshold_matches = self.service.find_pattern_matches(\n            text_pages=self.sample_pages,\n            pattern_types=[PatternType.SSN, PatternType.EMAIL],\n            confidence_threshold=0.1\n        )\n        \n        # Low threshold should find more or equal matches\n        self.assertGreaterEqual(len(low_threshold_matches), len(high_threshold_matches))\n        \n        # All matches should meet threshold\n        for match in high_threshold_matches:\n            self.assertGreaterEqual(match.confidence_score, 0.95)\n    \n    def test_multiple_pattern_types_search(self):\n        \"\"\"Test searching with multiple pattern types simultaneously.\"\"\"\n        matches = self.service.find_pattern_matches(\n            text_pages=self.sample_pages,\n            pattern_types=[\n                PatternType.SSN,\n                PatternType.CREDIT_CARD,\n                PatternType.PHONE,\n                PatternType.EMAIL,\n                PatternType.IP_ADDRESS,\n                PatternType.URL\n            ],\n            enable_validation=True,\n            confidence_threshold=0.5\n        )\n        \n        # Should find matches of different types\n        pattern_types_found = set(match.pattern_type for match in matches)\n        \n        self.assertIn(PatternType.SSN, pattern_types_found)\n        self.assertIn(PatternType.EMAIL, pattern_types_found)\n        self.assertIn(PatternType.CREDIT_CARD, pattern_types_found)\n        \n        # Verify each match has required properties\n        for match in matches:\n            self.assertIsInstance(match, PatternMatch)\n            self.assertGreater(len(match.matched_text), 0)\n            self.assertGreaterEqual(match.confidence_score, 0.5)\n            self.assertIn(match.page_number, [1, 2, 3])\n            self.assertIsInstance(match.position_info, dict)\n            self.assertIn('start', match.position_info)\n            self.assertIn('end', match.position_info)\n    \n    def test_performance_with_large_text(self):\n        \"\"\"Test performance with large text content.\"\"\"\n        # Create large text page\n        large_text = (\n            \"This is a test document with sensitive information. \"\n            \"SSN: 123-45-6789, Email: test@example.com, Phone: (555) 123-4567. \"\n        ) * 1000  # Repeat 1000 times\n        \n        large_page = [{\n            'page_number': 1,\n            'text': large_text\n        }]\n        \n        import time\n        start_time = time.time()\n        \n        matches = self.service.find_pattern_matches(\n            text_pages=large_page,\n            pattern_types=[PatternType.SSN, PatternType.EMAIL, PatternType.PHONE],\n            enable_validation=False,\n            confidence_threshold=0.5\n        )\n        \n        end_time = time.time()\n        processing_time = end_time - start_time\n        \n        # Should complete within reasonable time (adjust threshold as needed)\n        self.assertLess(processing_time, 10)  # 10 seconds maximum\n        \n        # Should find multiple instances\n        self.assertGreater(len(matches), 1000)  # At least 1000 of each pattern\n        \n        # Verify statistics\n        stats = self.service.get_pattern_statistics()\n        self.assertGreater(stats['total_matches'], 0)\n    \n    def test_pattern_deactivation(self):\n        \"\"\"Test pattern activation/deactivation functionality.\"\"\"\n        # Add custom pattern\n        self.service.add_custom_pattern(\n            name='deactivation_test',\n            pattern=r'\\bDEACT-\\d{3}\\b',\n            description='Deactivation test pattern',\n            pattern_type=PatternType.CUSTOM\n        )\n        \n        # Initially active\n        self.assertTrue(self.service.custom_patterns['deactivation_test'].is_active)\n        \n        # Deactivate pattern\n        self.service.custom_patterns['deactivation_test'].is_active = False\n        \n        # Test that deactivated pattern is not used in search\n        test_page = [{\n            'page_number': 1,\n            'text': 'Test with DEACT-123 pattern'\n        }]\n        \n        matches = self.service.find_pattern_matches(\n            text_pages=test_page,\n            pattern_names=['deactivation_test'],\n            confidence_threshold=0.1\n        )\n        \n        # Should find no matches because pattern is deactivated\n        deactivated_matches = [m for m in matches if m.pattern_name == 'deactivation_test']\n        self.assertEqual(len(deactivated_matches), 0)\n\n\nclass TestPatternDefinitionClass(unittest.TestCase):\n    \"\"\"Test cases for PatternDefinition data class.\"\"\"\n    \n    def test_pattern_definition_creation(self):\n        \"\"\"Test PatternDefinition creation and attributes.\"\"\"\n        pattern_def = PatternDefinition(\n            name='Test Pattern',\n            pattern=r'\\bTEST-\\d{3}\\b',\n            description='A test pattern',\n            pattern_type=PatternType.CUSTOM,\n            validation_mode=ValidationMode.BASIC,\n            match_mode=MatchMode.CASE_INSENSITIVE,\n            confidence_boost=0.1,\n            examples=['TEST-123', 'TEST-456'],\n            anti_examples=['test-123', 'TEST-12'],\n            is_active=True\n        )\n        \n        self.assertEqual(pattern_def.name, 'Test Pattern')\n        self.assertEqual(pattern_def.pattern, r'\\bTEST-\\d{3}\\b')\n        self.assertEqual(pattern_def.description, 'A test pattern')\n        self.assertEqual(pattern_def.pattern_type, PatternType.CUSTOM)\n        self.assertEqual(pattern_def.validation_mode, ValidationMode.BASIC)\n        self.assertEqual(pattern_def.match_mode, MatchMode.CASE_INSENSITIVE)\n        self.assertEqual(pattern_def.confidence_boost, 0.1)\n        self.assertEqual(pattern_def.examples, ['TEST-123', 'TEST-456'])\n        self.assertEqual(pattern_def.anti_examples, ['test-123', 'TEST-12'])\n        self.assertTrue(pattern_def.is_active)\n        \n    def test_pattern_definition_defaults(self):\n        \"\"\"Test PatternDefinition default values.\"\"\"\n        pattern_def = PatternDefinition(\n            name='Minimal Pattern',\n            pattern=r'\\bMIN\\b',\n            description='Minimal pattern definition',\n            pattern_type=PatternType.CUSTOM\n        )\n        \n        self.assertEqual(pattern_def.validation_mode, ValidationMode.BASIC)\n        self.assertEqual(pattern_def.match_mode, MatchMode.ANYWHERE)\n        self.assertEqual(pattern_def.confidence_boost, 0.0)\n        self.assertEqual(pattern_def.examples, [])\n        self.assertEqual(pattern_def.anti_examples, [])\n        self.assertIsNone(pattern_def.custom_validator)\n        self.assertTrue(pattern_def.is_active)\n\n\nclass TestPatternMatchClass(unittest.TestCase):\n    \"\"\"Test cases for PatternMatch data class.\"\"\"\n    \n    def test_pattern_match_creation(self):\n        \"\"\"Test PatternMatch creation and attributes.\"\"\"\n        match = PatternMatch(\n            pattern_name='Test Pattern',\n            pattern_type=PatternType.SSN,\n            matched_text='123-45-6789',\n            confidence_score=0.95,\n            page_number=1,\n            position_info={'start': 10, 'end': 21, 'length': 11},\n            context='SSN: 123-45-6789 for identification',\n            validation_passed=True,\n            validation_details={'method': 'basic', 'passed': True},\n            processing_time=0.005,\n            metadata={'pattern_type': 'ssn', 'source': 'predefined'}\n        )\n        \n        self.assertEqual(match.pattern_name, 'Test Pattern')\n        self.assertEqual(match.pattern_type, PatternType.SSN)\n        self.assertEqual(match.matched_text, '123-45-6789')\n        self.assertEqual(match.confidence_score, 0.95)\n        self.assertEqual(match.page_number, 1)\n        self.assertEqual(match.position_info['start'], 10)\n        self.assertEqual(match.position_info['end'], 21)\n        self.assertTrue(match.validation_passed)\n        self.assertEqual(match.processing_time, 0.005)\n\n\nif __name__ == '__main__':\n    unittest.main()"