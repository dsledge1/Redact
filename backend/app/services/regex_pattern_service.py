"""
Regex Pattern Service - Advanced pattern matching for sensitive data detection.

This service provides comprehensive regex pattern matching capabilities with
predefined patterns for common sensitive data types, custom pattern support,
confidence scoring, and validation tools.
"""

import re
import logging
import time
from typing import Dict, List, Optional, Tuple, Any, Set, Union
from enum import Enum
from dataclasses import dataclass, field
from collections import defaultdict
import hashlib

from ..utils.text_processing import (
    text_normalizer, text_preprocessor, measure_processing_time,
    get_text_fingerprint
)

logger = logging.getLogger(__name__)


class PatternType(Enum):
    """Types of predefined patterns."""
    SSN = "ssn"
    CREDIT_CARD = "credit_card"
    PHONE = "phone"
    EMAIL = "email"
    IP_ADDRESS = "ip_address"
    URL = "url"
    DATE = "date"
    DRIVERS_LICENSE = "drivers_license"
    MEDICAL_RECORD = "medical_record"
    BANK_ACCOUNT = "bank_account"
    CUSTOM = "custom"


class ValidationMode(Enum):
    """Pattern validation modes."""
    NONE = "none"
    BASIC = "basic"
    ADVANCED = "advanced"
    LUHN_CHECK = "luhn_check"


class MatchMode(Enum):
    """Pattern matching modes."""
    CASE_SENSITIVE = "case_sensitive"
    CASE_INSENSITIVE = "case_insensitive"
    WORD_BOUNDARY = "word_boundary"
    ANYWHERE = "anywhere"


@dataclass
class PatternDefinition:
    """Definition of a regex pattern with metadata."""
    name: str
    pattern: str
    description: str
    pattern_type: PatternType
    validation_mode: ValidationMode = ValidationMode.BASIC
    match_mode: MatchMode = MatchMode.ANYWHERE
    confidence_boost: float = 0.0
    examples: List[str] = field(default_factory=list)
    anti_examples: List[str] = field(default_factory=list)
    custom_validator: Optional[callable] = None
    is_active: bool = True


@dataclass
class PatternMatch:
    """Result of pattern matching operation."""
    pattern_name: str
    pattern_type: PatternType
    matched_text: str
    confidence_score: float
    page_number: int
    position_info: Dict[str, int]
    context: str
    validation_passed: bool
    validation_details: Dict[str, Any]
    processing_time: float
    metadata: Dict[str, Any] = field(default_factory=dict)


class RegexPatternService:
    """Advanced regex pattern matching service for sensitive data detection.
    
    Features:
    - Comprehensive predefined patterns for common sensitive data
    - Custom pattern support with validation
    - Pattern confidence scoring and validation
    - Luhn algorithm validation for credit cards
    - Context analysis and relevance scoring
    - Performance optimization and caching
    - Pattern testing and validation tools
    """
    
    def __init__(self, enable_caching: bool = True, cache_size: int = 1000):
        """Initialize the regex pattern service.
        
        Args:
            enable_caching: Whether to enable pattern result caching
            cache_size: Maximum cache size
        """
        self.enable_caching = enable_caching
        self.cache_size = cache_size
        
        # Pattern cache
        self._pattern_cache: Dict[str, Any] = {}
        self._compiled_patterns: Dict[str, re.Pattern] = {}
        
        # Initialize predefined patterns
        self.predefined_patterns = self._initialize_predefined_patterns()
        
        # Custom patterns storage
        self.custom_patterns: Dict[str, PatternDefinition] = {}
        
        # Statistics
        self.match_statistics = {
            'total_searches': 0,
            'total_matches': 0,
            'pattern_usage': defaultdict(int),
            'validation_stats': defaultdict(int),
            'cache_hits': 0,
            'processing_times': []
        }
        
        logger.info(f"RegexPatternService initialized with {len(self.predefined_patterns)} predefined patterns")
    
    def _initialize_predefined_patterns(self) -> Dict[str, PatternDefinition]:
        """Initialize predefined patterns for common sensitive data types."""
        patterns = {}
        
        # Social Security Numbers
        patterns['ssn_standard'] = PatternDefinition(
            name="SSN Standard Format",
            pattern=r'\b\d{3}-\d{2}-\d{4}\b',
            description="Social Security Number in XXX-XX-XXXX format",
            pattern_type=PatternType.SSN,
            match_mode=MatchMode.WORD_BOUNDARY,
            examples=["123-45-6789", "555-12-3456"],
            anti_examples=["1234-56-789", "123-456-7890"]
        )
        
        patterns['ssn_no_dashes'] = PatternDefinition(
            name="SSN No Dashes",
            pattern=r'\b\d{9}\b',
            description="Social Security Number without dashes (XXXXXXXXX format)",
            pattern_type=PatternType.SSN,
            match_mode=MatchMode.WORD_BOUNDARY,
            examples=["123456789", "555123456"],
            anti_examples=["1234567890", "12345678"]
        )
        
        patterns['ssn_spaces'] = PatternDefinition(\n            name=\"SSN with Spaces\",\n            pattern=r'\\b\\d{3}\\s+\\d{2}\\s+\\d{4}\\b',\n            description=\"Social Security Number with spaces (XXX XX XXXX format)\",\n            pattern_type=PatternType.SSN,\n            match_mode=MatchMode.WORD_BOUNDARY,\n            examples=[\"123 45 6789\", \"555 12 3456\"],\n            anti_examples=[\"1234 56 789\", \"123 456 7890\"]\n        )\n        \n        # Credit Card Numbers\n        patterns['cc_visa'] = PatternDefinition(\n            name=\"Visa Credit Card\",\n            pattern=r'\\b4\\d{3}[\\s-]?\\d{4}[\\s-]?\\d{4}[\\s-]?\\d{4}\\b',\n            description=\"Visa credit card numbers starting with 4\",\n            pattern_type=PatternType.CREDIT_CARD,\n            validation_mode=ValidationMode.LUHN_CHECK,\n            examples=[\"4111-1111-1111-1111\", \"4111 1111 1111 1111\", \"4111111111111111\"],\n            anti_examples=[\"5111-1111-1111-1111\", \"411-1111-1111-1111\"]\n        )\n        \n        patterns['cc_mastercard'] = PatternDefinition(\n            name=\"MasterCard Credit Card\",\n            pattern=r'\\b5[1-5]\\d{2}[\\s-]?\\d{4}[\\s-]?\\d{4}[\\s-]?\\d{4}\\b',\n            description=\"MasterCard credit card numbers starting with 51-55\",\n            pattern_type=PatternType.CREDIT_CARD,\n            validation_mode=ValidationMode.LUHN_CHECK,\n            examples=[\"5555-5555-5555-4444\", \"5555 5555 5555 4444\"],\n            anti_examples=[\"4555-5555-5555-4444\", \"5055-5555-5555-4444\"]\n        )\n        \n        patterns['cc_amex'] = PatternDefinition(\n            name=\"American Express Credit Card\",\n            pattern=r'\\b3[47]\\d{2}[\\s-]?\\d{6}[\\s-]?\\d{5}\\b',\n            description=\"American Express credit card numbers\",\n            pattern_type=PatternType.CREDIT_CARD,\n            validation_mode=ValidationMode.LUHN_CHECK,\n            examples=[\"3782-822463-10005\", \"3782 822463 10005\"],\n            anti_examples=[\"3882-822463-10005\", \"37-822463-10005\"]\n        )\n        \n        patterns['cc_discover'] = PatternDefinition(\n            name=\"Discover Credit Card\",\n            pattern=r'\\b6(?:011|5\\d{2})[\\s-]?\\d{4}[\\s-]?\\d{4}[\\s-]?\\d{4}\\b',\n            description=\"Discover credit card numbers\",\n            pattern_type=PatternType.CREDIT_CARD,\n            validation_mode=ValidationMode.LUHN_CHECK,\n            examples=[\"6011-1111-1111-1117\", \"6011 1111 1111 1117\"],\n            anti_examples=[\"7011-1111-1111-1117\", \"601-1111-1111-1117\"]\n        )\n        \n        # Phone Numbers\n        patterns['phone_us_standard'] = PatternDefinition(\n            name=\"US Phone Number Standard\",\n            pattern=r'\\b\\(?\\d{3}\\)?[\\s.-]?\\d{3}[\\s.-]?\\d{4}\\b',\n            description=\"US phone numbers in various formats\",\n            pattern_type=PatternType.PHONE,\n            examples=[\"(555) 123-4567\", \"555-123-4567\", \"555.123.4567\", \"5551234567\"],\n            anti_examples=[\"555-123-45678\", \"55-123-4567\"]\n        )\n        \n        patterns['phone_international'] = PatternDefinition(\n            name=\"International Phone Number\",\n            pattern=r'\\+\\d{1,3}[\\s.-]?\\(?\\d{1,4}\\)?[\\s.-]?\\d{1,4}[\\s.-]?\\d{1,9}',\n            description=\"International phone numbers with country code\",\n            pattern_type=PatternType.PHONE,\n            examples=[\"+1-555-123-4567\", \"+44 20 7946 0958\", \"+33 1 42 86 83 26\"],\n            anti_examples=[\"+1234567890123456\", \"1-555-123-4567\"]\n        )\n        \n        # Email Addresses\n        patterns['email_standard'] = PatternDefinition(\n            name=\"Email Address\",\n            pattern=r'\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,}\\b',\n            description=\"Standard email addresses\",\n            pattern_type=PatternType.EMAIL,\n            match_mode=MatchMode.CASE_INSENSITIVE,\n            examples=[\"user@example.com\", \"test.email+tag@domain.co.uk\"],\n            anti_examples=[\"plainaddress\", \"@missingdomain.com\"]\n        )\n        \n        # IP Addresses\n        patterns['ipv4'] = PatternDefinition(\n            name=\"IPv4 Address\",\n            pattern=r'\\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\b',\n            description=\"IPv4 addresses\",\n            pattern_type=PatternType.IP_ADDRESS,\n            examples=[\"192.168.1.1\", \"10.0.0.1\", \"172.16.0.1\"],\n            anti_examples=[\"256.256.256.256\", \"192.168.1\"]\n        )\n        \n        patterns['ipv6'] = PatternDefinition(\n            name=\"IPv6 Address\",\n            pattern=r'\\b(?:[0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}\\b',\n            description=\"IPv6 addresses (full format)\",\n            pattern_type=PatternType.IP_ADDRESS,\n            match_mode=MatchMode.CASE_INSENSITIVE,\n            examples=[\"2001:0db8:85a3:0000:0000:8a2e:0370:7334\"],\n            anti_examples=[\"2001:db8:85a3::8a2e:370:7334\"]  # Compressed format needs separate pattern\n        )\n        \n        # URLs\n        patterns['url_http'] = PatternDefinition(\n            name=\"HTTP/HTTPS URL\",\n            pattern=r'\\bhttps?://[A-Za-z0-9.-]+(?:/[A-Za-z0-9./_?#&=-]*)?\\b',\n            description=\"HTTP and HTTPS URLs\",\n            pattern_type=PatternType.URL,\n            match_mode=MatchMode.CASE_INSENSITIVE,\n            examples=[\"https://example.com\", \"http://www.test.org/path?param=value\"],\n            anti_examples=[\"ftp://example.com\", \"www.example.com\"]\n        )\n        \n        # Date Patterns\n        patterns['date_mm_dd_yyyy'] = PatternDefinition(\n            name=\"Date MM/DD/YYYY\",\n            pattern=r'\\b(?:0[1-9]|1[0-2])/(?:0[1-9]|[12]\\d|3[01])/(?:19|20)\\d{2}\\b',\n            description=\"Dates in MM/DD/YYYY format\",\n            pattern_type=PatternType.DATE,\n            examples=[\"12/25/2023\", \"01/01/2000\", \"05/15/1990\"],\n            anti_examples=[\"13/01/2023\", \"12/32/2023\", \"12/25/23\"]\n        )\n        \n        patterns['date_dd_mm_yyyy'] = PatternDefinition(\n            name=\"Date DD-MM-YYYY\",\n            pattern=r'\\b(?:0[1-9]|[12]\\d|3[01])-(?:0[1-9]|1[0-2])-(?:19|20)\\d{2}\\b',\n            description=\"Dates in DD-MM-YYYY format\",\n            pattern_type=PatternType.DATE,\n            examples=[\"25-12-2023\", \"01-01-2000\", \"15-05-1990\"],\n            anti_examples=[\"32-12-2023\", \"25-13-2023\", \"25-12-23\"]\n        )\n        \n        patterns['date_iso'] = PatternDefinition(\n            name=\"Date ISO 8601\",\n            pattern=r'\\b(?:19|20)\\d{2}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[12]\\d|3[01])\\b',\n            description=\"Dates in ISO 8601 format (YYYY-MM-DD)\",\n            pattern_type=PatternType.DATE,\n            examples=[\"2023-12-25\", \"2000-01-01\", \"1990-05-15\"],\n            anti_examples=[\"2023-13-25\", \"2023-12-32\", \"23-12-25\"]\n        )\n        \n        # Driver's License (US state examples)\n        patterns['drivers_license_ca'] = PatternDefinition(\n            name=\"California Driver's License\",\n            pattern=r'\\b[A-Z]\\d{7}\\b',\n            description=\"California driver's license format\",\n            pattern_type=PatternType.DRIVERS_LICENSE,\n            examples=[\"A1234567\", \"Z9876543\"],\n            anti_examples=[\"1A234567\", \"AB123456\"]\n        )\n        \n        patterns['drivers_license_ny'] = PatternDefinition(\n            name=\"New York Driver's License\",\n            pattern=r'\\b\\d{9}\\b',\n            description=\"New York driver's license format (9 digits)\",\n            pattern_type=PatternType.DRIVERS_LICENSE,\n            examples=[\"123456789\", \"987654321\"],\n            anti_examples=[\"12345678\", \"1234567890\"]\n        )\n        \n        # Medical Record Numbers\n        patterns['mrn_standard'] = PatternDefinition(\n            name=\"Medical Record Number\",\n            pattern=r'\\b(?:MRN|MR#?)\\s*:?\\s*\\d{6,10}\\b',\n            description=\"Medical record numbers with MRN prefix\",\n            pattern_type=PatternType.MEDICAL_RECORD,\n            match_mode=MatchMode.CASE_INSENSITIVE,\n            examples=[\"MRN: 1234567\", \"MR# 12345678\", \"MRN 123456789\"],\n            anti_examples=[\"MRN: 12345\", \"MRN: 12345678901\"]\n        )\n        \n        # Bank Account Numbers\n        patterns['bank_routing'] = PatternDefinition(\n            name=\"Bank Routing Number\",\n            pattern=r'\\b\\d{9}\\b',\n            description=\"US bank routing numbers (9 digits)\",\n            pattern_type=PatternType.BANK_ACCOUNT,\n            custom_validator=self._validate_routing_number,\n            examples=[\"123456789\", \"021000021\"],\n            anti_examples=[\"12345678\", \"1234567890\"]\n        )\n        \n        patterns['bank_account'] = PatternDefinition(\n            name=\"Bank Account Number\",\n            pattern=r'\\b\\d{8,17}\\b',\n            description=\"Bank account numbers (8-17 digits)\",\n            pattern_type=PatternType.BANK_ACCOUNT,\n            examples=[\"12345678\", \"1234567890123456\"],\n            anti_examples=[\"1234567\", \"123456789012345678\"]\n        )\n        \n        return patterns\n    \n    @measure_processing_time\n    def find_pattern_matches(\n        self,\n        text_pages: List[Dict[str, Any]],\n        pattern_names: Optional[List[str]] = None,\n        pattern_types: Optional[List[PatternType]] = None,\n        enable_validation: bool = True,\n        confidence_threshold: float = 0.7\n    ) -> List[PatternMatch]:\n        \"\"\"Find pattern matches across multiple pages.\n        \n        Args:\n            text_pages: List of page dictionaries with 'page_number' and 'text' keys\n            pattern_names: Specific patterns to search for (None for all active)\n            pattern_types: Specific pattern types to search for\n            enable_validation: Whether to perform pattern validation\n            confidence_threshold: Minimum confidence threshold for matches\n            \n        Returns:\n            List of pattern matches found\n        \"\"\"\n        start_time = time.time()\n        all_matches = []\n        \n        try:\n            # Determine patterns to use\n            active_patterns = self._get_active_patterns(pattern_names, pattern_types)\n            \n            if not active_patterns:\n                logger.warning(\"No active patterns found for search\")\n                return []\n            \n            logger.info(f\"Searching with {len(active_patterns)} patterns across {len(text_pages)} pages\")\n            \n            # Process each page\n            for page_data in text_pages:\n                page_number = page_data.get('page_number', 1)\n                page_text = page_data.get('text', '')\n                \n                if not page_text.strip():\n                    continue\n                \n                # Find matches on this page\n                page_matches = self._find_page_pattern_matches(\n                    page_text, page_number, active_patterns, enable_validation\n                )\n                \n                # Filter by confidence threshold\n                filtered_matches = [\n                    match for match in page_matches \n                    if match.confidence_score >= confidence_threshold\n                ]\n                \n                all_matches.extend(filtered_matches)\n            \n            # Sort matches by confidence (highest first) then by page number\n            all_matches.sort(key=lambda x: (-x.confidence_score, x.page_number))\n            \n            # Update statistics\n            self.match_statistics['total_searches'] += 1\n            self.match_statistics['total_matches'] += len(all_matches)\n            self.match_statistics['processing_times'].append(time.time() - start_time)\n            \n            for match in all_matches:\n                self.match_statistics['pattern_usage'][match.pattern_name] += 1\n            \n            logger.info(f\"Found {len(all_matches)} pattern matches in {time.time() - start_time:.3f} seconds\")\n            \n            return all_matches\n            \n        except Exception as e:\n            logger.error(f\"Error finding pattern matches: {e}\")\n            return []\n    \n    def _get_active_patterns(self, pattern_names: Optional[List[str]], pattern_types: Optional[List[PatternType]]) -> Dict[str, PatternDefinition]:\n        \"\"\"Get active patterns based on filters.\n        \n        Args:\n            pattern_names: Specific pattern names to include\n            pattern_types: Specific pattern types to include\n            \n        Returns:\n            Dictionary of active patterns\n        \"\"\"\n        all_patterns = {**self.predefined_patterns, **self.custom_patterns}\n        active_patterns = {}\n        \n        for name, pattern_def in all_patterns.items():\n            if not pattern_def.is_active:\n                continue\n            \n            # Filter by pattern names if specified\n            if pattern_names and name not in pattern_names:\n                continue\n            \n            # Filter by pattern types if specified\n            if pattern_types and pattern_def.pattern_type not in pattern_types:\n                continue\n            \n            active_patterns[name] = pattern_def\n        \n        return active_patterns\n    \n    def _find_page_pattern_matches(\n        self,\n        page_text: str,\n        page_number: int,\n        patterns: Dict[str, PatternDefinition],\n        enable_validation: bool\n    ) -> List[PatternMatch]:\n        \"\"\"Find pattern matches on a single page.\n        \n        Args:\n            page_text: Text content of the page\n            page_number: Page number\n            patterns: Dictionary of patterns to search for\n            enable_validation: Whether to perform validation\n            \n        Returns:\n            List of pattern matches on this page\n        \"\"\"\n        matches = []\n        \n        for pattern_name, pattern_def in patterns.items():\n            try:\n                pattern_matches = self._find_pattern_matches_in_text(\n                    page_text, page_number, pattern_name, pattern_def, enable_validation\n                )\n                matches.extend(pattern_matches)\n                \n            except Exception as e:\n                logger.error(f\"Error finding matches for pattern '{pattern_name}': {e}\")\n        \n        return matches\n    \n    def _find_pattern_matches_in_text(\n        self,\n        text: str,\n        page_number: int,\n        pattern_name: str,\n        pattern_def: PatternDefinition,\n        enable_validation: bool\n    ) -> List[PatternMatch]:\n        \"\"\"Find matches for a specific pattern in text.\n        \n        Args:\n            text: Text to search in\n            page_number: Page number\n            pattern_name: Name of the pattern\n            pattern_def: Pattern definition\n            enable_validation: Whether to perform validation\n            \n        Returns:\n            List of pattern matches\n        \"\"\"\n        matches = []\n        start_time = time.time()\n        \n        try:\n            # Get compiled pattern\n            compiled_pattern = self._get_compiled_pattern(pattern_name, pattern_def)\n            \n            # Find all matches\n            for match_obj in compiled_pattern.finditer(text):\n                matched_text = match_obj.group(0)\n                \n                # Get match position info\n                position_info = {\n                    'start': match_obj.start(),\n                    'end': match_obj.end(),\n                    'length': len(matched_text)\n                }\n                \n                # Get context around match\n                context = self._get_pattern_context(matched_text, text)\n                \n                # Perform validation if enabled\n                validation_passed = True\n                validation_details = {'method': 'none'}\n                \n                if enable_validation:\n                    validation_passed, validation_details = self._validate_pattern_match(\n                        matched_text, pattern_def\n                    )\n                \n                # Calculate confidence score\n                confidence_score = self._calculate_pattern_confidence(\n                    matched_text, pattern_def, validation_passed, context\n                )\n                \n                # Create match result\n                pattern_match = PatternMatch(\n                    pattern_name=pattern_name,\n                    pattern_type=pattern_def.pattern_type,\n                    matched_text=matched_text,\n                    confidence_score=confidence_score,\n                    page_number=page_number,\n                    position_info=position_info,\n                    context=context,\n                    validation_passed=validation_passed,\n                    validation_details=validation_details,\n                    processing_time=time.time() - start_time,\n                    metadata={\n                        'pattern_description': pattern_def.description,\n                        'match_mode': pattern_def.match_mode.value,\n                        'validation_mode': pattern_def.validation_mode.value\n                    }\n                )\n                \n                matches.append(pattern_match)\n        \n        except Exception as e:\n            logger.error(f\"Error finding matches for pattern '{pattern_name}': {e}\")\n        \n        return matches\n    \n    def _get_compiled_pattern(self, pattern_name: str, pattern_def: PatternDefinition) -> re.Pattern:\n        \"\"\"Get compiled regex pattern with caching.\n        \n        Args:\n            pattern_name: Name of the pattern\n            pattern_def: Pattern definition\n            \n        Returns:\n            Compiled regex pattern\n        \"\"\"\n        cache_key = f\"{pattern_name}_{pattern_def.match_mode.value}\"\n        \n        if cache_key not in self._compiled_patterns:\n            flags = 0\n            \n            if pattern_def.match_mode == MatchMode.CASE_INSENSITIVE:\n                flags |= re.IGNORECASE\n            \n            try:\n                self._compiled_patterns[cache_key] = re.compile(pattern_def.pattern, flags)\n            except re.error as e:\n                logger.error(f\"Invalid regex pattern '{pattern_name}': {e}\")\n                raise\n        \n        return self._compiled_patterns[cache_key]\n    \n    def _get_pattern_context(self, matched_text: str, full_text: str, context_chars: int = 100) -> str:\n        \"\"\"Get context around a pattern match.\n        \n        Args:\n            matched_text: The matched text\n            full_text: Full text content\n            context_chars: Number of characters to include on each side\n            \n        Returns:\n            Context string\n        \"\"\"\n        try:\n            match_start = full_text.find(matched_text)\n            if match_start == -1:\n                return matched_text\n            \n            start_idx = max(0, match_start - context_chars)\n            end_idx = min(len(full_text), match_start + len(matched_text) + context_chars)\n            \n            context = full_text[start_idx:end_idx]\n            \n            # Add ellipsis if truncated\n            if start_idx > 0:\n                context = '...' + context\n            if end_idx < len(full_text):\n                context = context + '...'\n            \n            return context\n            \n        except Exception as e:\n            logger.warning(f\"Error getting pattern context: {e}\")\n            return matched_text\n    \n    def _validate_pattern_match(self, matched_text: str, pattern_def: PatternDefinition) -> Tuple[bool, Dict[str, Any]]:\n        \"\"\"Validate a pattern match based on its validation mode.\n        \n        Args:\n            matched_text: The matched text to validate\n            pattern_def: Pattern definition with validation rules\n            \n        Returns:\n            Tuple of (validation_passed, validation_details)\n        \"\"\"\n        validation_details = {'method': pattern_def.validation_mode.value}\n        \n        try:\n            if pattern_def.validation_mode == ValidationMode.NONE:\n                return True, validation_details\n            \n            elif pattern_def.validation_mode == ValidationMode.BASIC:\n                # Basic validation - just check if it matches the pattern\n                return True, validation_details\n            \n            elif pattern_def.validation_mode == ValidationMode.LUHN_CHECK:\n                # Luhn algorithm validation for credit cards\n                return self._validate_luhn(matched_text, validation_details)\n            \n            elif pattern_def.validation_mode == ValidationMode.ADVANCED:\n                # Advanced validation using custom validator if available\n                if pattern_def.custom_validator:\n                    try:\n                        result = pattern_def.custom_validator(matched_text)\n                        validation_details['custom_validation'] = True\n                        return result, validation_details\n                    except Exception as e:\n                        validation_details['custom_validation_error'] = str(e)\n                        return False, validation_details\n                \n                # Fall back to basic validation\n                return True, validation_details\n            \n            else:\n                return True, validation_details\n        \n        except Exception as e:\n            validation_details['validation_error'] = str(e)\n            return False, validation_details\n    \n    def _validate_luhn(self, number_str: str, validation_details: Dict[str, Any]) -> Tuple[bool, Dict[str, Any]]:\n        \"\"\"Validate a number using the Luhn algorithm.\n        \n        Args:\n            number_str: Number string to validate\n            validation_details: Dictionary to store validation details\n            \n        Returns:\n            Tuple of (is_valid, validation_details)\n        \"\"\"\n        try:\n            # Remove non-digit characters\n            digits = re.sub(r'\\D', '', number_str)\n            \n            if not digits or len(digits) < 2:\n                validation_details['luhn_error'] = 'Invalid number format'\n                return False, validation_details\n            \n            # Luhn algorithm implementation\n            def luhn_checksum(digits):\n                def luhn_digit(d, even):\n                    return d if not even else (d * 2) if d < 5 else (d * 2) - 9\n                \n                return sum(luhn_digit(int(d), i % 2 == 0) for i, d in enumerate(reversed(digits)))\n            \n            is_valid = luhn_checksum(digits) % 10 == 0\n            validation_details['luhn_checksum'] = luhn_checksum(digits)\n            validation_details['luhn_valid'] = is_valid\n            \n            return is_valid, validation_details\n        \n        except Exception as e:\n            validation_details['luhn_error'] = str(e)\n            return False, validation_details\n    \n    def _validate_routing_number(self, routing_str: str) -> bool:\n        \"\"\"Validate a US bank routing number.\n        \n        Args:\n            routing_str: Routing number string\n            \n        Returns:\n            True if valid routing number\n        \"\"\"\n        try:\n            # Remove non-digit characters\n            digits = re.sub(r'\\D', '', routing_str)\n            \n            if len(digits) != 9:\n                return False\n            \n            # Routing number checksum algorithm\n            checksum = (\n                3 * int(digits[0]) +\n                7 * int(digits[1]) +\n                1 * int(digits[2]) +\n                3 * int(digits[3]) +\n                7 * int(digits[4]) +\n                1 * int(digits[5]) +\n                3 * int(digits[6]) +\n                7 * int(digits[7]) +\n                1 * int(digits[8])\n            )\n            \n            return checksum % 10 == 0\n        \n        except Exception as e:\n            logger.debug(f\"Routing number validation error: {e}\")\n            return False\n    \n    def _calculate_pattern_confidence(\n        self,\n        matched_text: str,\n        pattern_def: PatternDefinition,\n        validation_passed: bool,\n        context: str\n    ) -> float:\n        \"\"\"Calculate confidence score for a pattern match.\n        \n        Args:\n            matched_text: The matched text\n            pattern_def: Pattern definition\n            validation_passed: Whether validation passed\n            context: Context around the match\n            \n        Returns:\n            Confidence score (0.0 to 1.0)\n        \"\"\"\n        try:\n            base_confidence = 0.8  # Base confidence for pattern match\n            \n            # Adjust for validation results\n            if pattern_def.validation_mode != ValidationMode.NONE:\n                if validation_passed:\n                    base_confidence += 0.15  # Boost for passed validation\n                else:\n                    base_confidence -= 0.3   # Penalty for failed validation\n            \n            # Apply pattern-specific confidence boost\n            base_confidence += pattern_def.confidence_boost\n            \n            # Context analysis - look for relevant keywords\n            context_boost = self._analyze_context_relevance(context, pattern_def.pattern_type)\n            base_confidence += context_boost\n            \n            # Normalize to 0.0-1.0 range\n            confidence = max(0.0, min(1.0, base_confidence))\n            \n            return confidence\n        \n        except Exception as e:\n            logger.debug(f\"Error calculating pattern confidence: {e}\")\n            return 0.5  # Default confidence\n    \n    def _analyze_context_relevance(self, context: str, pattern_type: PatternType) -> float:\n        \"\"\"Analyze context for relevance to pattern type.\n        \n        Args:\n            context: Context text around the match\n            pattern_type: Type of pattern matched\n            \n        Returns:\n            Confidence boost based on context (-0.2 to +0.2)\n        \"\"\"\n        try:\n            context_lower = context.lower()\n            boost = 0.0\n            \n            # Define relevant keywords for each pattern type\n            relevance_keywords = {\n                PatternType.SSN: ['social', 'security', 'ssn', 'ss#', 'tax', 'id'],\n                PatternType.CREDIT_CARD: ['credit', 'card', 'visa', 'mastercard', 'amex', 'discover', 'payment', 'cc#'],\n                PatternType.PHONE: ['phone', 'call', 'mobile', 'cell', 'tel', 'contact', 'number'],\n                PatternType.EMAIL: ['email', 'e-mail', 'contact', 'send', 'reply', 'address'],\n                PatternType.DATE: ['date', 'born', 'birth', 'dob', 'expir', 'valid', 'until'],\n                PatternType.BANK_ACCOUNT: ['account', 'bank', 'routing', 'deposit', 'ach', 'wire'],\n                PatternType.MEDICAL_RECORD: ['patient', 'medical', 'hospital', 'chart', 'record', 'mrn'],\n                PatternType.DRIVERS_LICENSE: ['license', 'driver', 'dl#', 'dmv', 'permit']\n            }\n            \n            keywords = relevance_keywords.get(pattern_type, [])\n            \n            # Count keyword occurrences\n            keyword_count = sum(1 for keyword in keywords if keyword in context_lower)\n            \n            if keyword_count > 0:\n                boost = min(0.2, keyword_count * 0.05)  # Max boost of 0.2\n            \n            # Penalty for irrelevant context (e.g., random numbers)\n            if pattern_type in [PatternType.SSN, PatternType.CREDIT_CARD, PatternType.PHONE]:\n                irrelevant_keywords = ['page', 'figure', 'table', 'reference', 'footnote']\n                if any(keyword in context_lower for keyword in irrelevant_keywords):\n                    boost -= 0.1\n            \n            return boost\n        \n        except Exception as e:\n            logger.debug(f\"Error analyzing context relevance: {e}\")\n            return 0.0\n    \n    def add_custom_pattern(\n        self,\n        name: str,\n        pattern: str,\n        description: str,\n        pattern_type: PatternType = PatternType.CUSTOM,\n        **kwargs\n    ) -> bool:\n        \"\"\"Add a custom pattern to the service.\n        \n        Args:\n            name: Unique name for the pattern\n            pattern: Regex pattern string\n            description: Human-readable description\n            pattern_type: Type of pattern\n            **kwargs: Additional PatternDefinition parameters\n            \n        Returns:\n            True if pattern was added successfully\n        \"\"\"\n        try:\n            # Test pattern compilation\n            re.compile(pattern)\n            \n            # Create pattern definition\n            pattern_def = PatternDefinition(\n                name=name,\n                pattern=pattern,\n                description=description,\n                pattern_type=pattern_type,\n                **kwargs\n            )\n            \n            self.custom_patterns[name] = pattern_def\n            logger.info(f\"Added custom pattern '{name}'\")\n            return True\n        \n        except re.error as e:\n            logger.error(f\"Invalid regex pattern '{name}': {e}\")\n            return False\n        except Exception as e:\n            logger.error(f\"Error adding custom pattern '{name}': {e}\")\n            return False\n    \n    def remove_custom_pattern(self, name: str) -> bool:\n        \"\"\"Remove a custom pattern.\n        \n        Args:\n            name: Name of the pattern to remove\n            \n        Returns:\n            True if pattern was removed successfully\n        \"\"\"\n        if name in self.custom_patterns:\n            del self.custom_patterns[name]\n            # Also remove from compiled patterns cache\n            cache_keys_to_remove = [key for key in self._compiled_patterns.keys() if key.startswith(f\"{name}_\")]\n            for key in cache_keys_to_remove:\n                del self._compiled_patterns[key]\n            logger.info(f\"Removed custom pattern '{name}'\")\n            return True\n        return False\n    \n    def test_pattern(self, pattern: str, test_strings: List[str]) -> Dict[str, Any]:\n        \"\"\"Test a regex pattern against test strings.\n        \n        Args:\n            pattern: Regex pattern to test\n            test_strings: List of strings to test against\n            \n        Returns:\n            Dictionary with test results\n        \"\"\"\n        try:\n            compiled_pattern = re.compile(pattern)\n            results = {\n                'pattern': pattern,\n                'valid_pattern': True,\n                'test_results': []\n            }\n            \n            for test_string in test_strings:\n                matches = list(compiled_pattern.finditer(test_string))\n                results['test_results'].append({\n                    'test_string': test_string,\n                    'matches': [{\n                        'matched_text': match.group(0),\n                        'start': match.start(),\n                        'end': match.end()\n                    } for match in matches],\n                    'match_count': len(matches)\n                })\n            \n            return results\n        \n        except re.error as e:\n            return {\n                'pattern': pattern,\n                'valid_pattern': False,\n                'error': str(e),\n                'test_results': []\n            }\n    \n    def get_pattern_statistics(self) -> Dict[str, Any]:\n        \"\"\"Get comprehensive pattern matching statistics.\n        \n        Returns:\n            Dictionary with statistics\n        \"\"\"\n        stats = self.match_statistics.copy()\n        \n        # Calculate additional metrics\n        if stats['processing_times']:\n            stats['average_processing_time'] = sum(stats['processing_times']) / len(stats['processing_times'])\n            stats['max_processing_time'] = max(stats['processing_times'])\n            stats['min_processing_time'] = min(stats['processing_times'])\n        else:\n            stats['average_processing_time'] = 0\n            stats['max_processing_time'] = 0\n            stats['min_processing_time'] = 0\n        \n        # Pattern type distribution\n        pattern_type_counts = defaultdict(int)\n        for pattern_name, count in stats['pattern_usage'].items():\n            if pattern_name in self.predefined_patterns:\n                pattern_type = self.predefined_patterns[pattern_name].pattern_type\n            elif pattern_name in self.custom_patterns:\n                pattern_type = self.custom_patterns[pattern_name].pattern_type\n            else:\n                pattern_type = PatternType.CUSTOM\n            \n            pattern_type_counts[pattern_type.value] += count\n        \n        stats['pattern_type_distribution'] = dict(pattern_type_counts)\n        \n        # Cache statistics\n        stats['compiled_patterns_cached'] = len(self._compiled_patterns)\n        stats['custom_patterns_count'] = len(self.custom_patterns)\n        stats['predefined_patterns_count'] = len(self.predefined_patterns)\n        \n        return stats\n    \n    def clear_cache(self):\n        \"\"\"Clear pattern compilation cache.\"\"\"\n        self._pattern_cache.clear()\n        self._compiled_patterns.clear()\n        logger.info(\"Pattern cache cleared\")\n    \n    def get_available_patterns(self) -> Dict[str, Dict[str, Any]]:\n        \"\"\"Get information about all available patterns.\n        \n        Returns:\n            Dictionary with pattern information\n        \"\"\"\n        all_patterns = {**self.predefined_patterns, **self.custom_patterns}\n        pattern_info = {}\n        \n        for name, pattern_def in all_patterns.items():\n            pattern_info[name] = {\n                'description': pattern_def.description,\n                'pattern_type': pattern_def.pattern_type.value,\n                'validation_mode': pattern_def.validation_mode.value,\n                'match_mode': pattern_def.match_mode.value,\n                'is_active': pattern_def.is_active,\n                'examples': pattern_def.examples,\n                'anti_examples': pattern_def.anti_examples,\n                'is_custom': name in self.custom_patterns\n            }\n        \n        return pattern_info