/**\n * Unit tests for operation utility functions\n */\n\nimport { jest } from '@jest/globals';\nimport {\n  parsePageRanges,\n  validatePageRanges,\n  optimizePageRanges,\n  formatPageRanges,\n  validateMergeFiles,\n  calculateMergeSize,\n  generateMergePreview,\n  optimizeFileOrder,\n  assessExtractionCapabilities,\n  estimateExtractionSize,\n  validateExtractionParams,\n  formatExtractionResults,\n  calculateOperationProgress,\n  estimateCompletionTime,\n  formatOperationStatus,\n  generateOperationSummary,\n  validateOperationLimits,\n  checkOperationCompatibility,\n  sanitizeOperationParams,\n  generateValidationMessages,\n  formatFileSize,\n  formatProcessingTime,\n  generateDownloadFilename\n} from '../../utils/operationUtils';\nimport type {\n  PageRange,\n  ExtractionFormData,\n  ExtractedData,\n  ProcessingJobWithResults,\n  PDFDocument\n} from '../../types';\n\ndescribe('operationUtils', () => {\n  describe('Page Range Utilities', () => {\n    describe('parsePageRanges', () => {\n      it('parses single page ranges', () => {\n        expect(parsePageRanges('5')).toEqual([{ start: 5, end: 5 }]);\n        expect(parsePageRanges('1,3,5')).toEqual([\n          { start: 1, end: 1 },\n          { start: 3, end: 3 },\n          { start: 5, end: 5 }\n        ]);\n      });\n\n      it('parses page ranges with dashes', () => {\n        expect(parsePageRanges('1-5')).toEqual([{ start: 1, end: 5 }]);\n        expect(parsePageRanges('1-5,8-10')).toEqual([\n          { start: 1, end: 5 },\n          { start: 8, end: 10 }\n        ]);\n      });\n\n      it('parses mixed format ranges', () => {\n        expect(parsePageRanges('1-5,8,10-12')).toEqual([\n          { start: 1, end: 5 },\n          { start: 8, end: 8 },\n          { start: 10, end: 12 }\n        ]);\n      });\n\n      it('handles whitespace', () => {\n        expect(parsePageRanges(' 1 - 5 , 8 , 10 - 12 ')).toEqual([\n          { start: 1, end: 5 },\n          { start: 8, end: 8 },\n          { start: 10, end: 12 }\n        ]);\n      });\n\n      it('returns empty array for empty input', () => {\n        expect(parsePageRanges('')).toEqual([]);\n        expect(parsePageRanges('   ')).toEqual([]);\n      });\n\n      it('throws error for invalid formats', () => {\n        expect(() => parsePageRanges('abc')).toThrow('Invalid page number');\n        expect(() => parsePageRanges('1-abc')).toThrow('Invalid range format');\n        expect(() => parsePageRanges('5-1')).toThrow('start page (5) cannot be greater than end page (1)');\n      });\n    });\n\n    describe('validatePageRanges', () => {\n      it('validates correct ranges', () => {\n        const ranges = [{ start: 1, end: 5 }, { start: 8, end: 10 }];\n        const result = validatePageRanges(ranges, 20);\n        \n        expect(result.isValid).toBe(true);\n        expect(result.errors).toHaveLength(0);\n      });\n\n      it('detects invalid page numbers', () => {\n        const ranges = [{ start: 0, end: 5 }];\n        const result = validatePageRanges(ranges, 20);\n        \n        expect(result.isValid).toBe(false);\n        expect(result.errors[0]).toContain('Page numbers must be positive');\n      });\n\n      it('detects pages exceeding document length', () => {\n        const ranges = [{ start: 1, end: 25 }];\n        const result = validatePageRanges(ranges, 20);\n        \n        expect(result.isValid).toBe(false);\n        expect(result.errors[0]).toContain('exceeds document length');\n      });\n\n      it('detects invalid ranges (start > end)', () => {\n        const ranges = [{ start: 10, end: 5 }];\n        const result = validatePageRanges(ranges, 20);\n        \n        expect(result.isValid).toBe(false);\n        expect(result.errors[0]).toContain('Invalid range: 10-5');\n      });\n\n      it('detects overlapping ranges as warnings', () => {\n        const ranges = [{ start: 1, end: 5 }, { start: 3, end: 8 }];\n        const result = validatePageRanges(ranges, 20);\n        \n        expect(result.isValid).toBe(true);\n        expect(result.warnings).toContain('Overlapping ranges detected: 1-5 and 3-8');\n      });\n\n      it('requires at least one range', () => {\n        const result = validatePageRanges([], 20);\n        \n        expect(result.isValid).toBe(false);\n        expect(result.errors[0]).toContain('At least one page range must be specified');\n      });\n    });\n\n    describe('optimizePageRanges', () => {\n      it('merges overlapping ranges', () => {\n        const ranges = [{ start: 1, end: 5 }, { start: 3, end: 8 }];\n        const optimized = optimizePageRanges(ranges);\n        \n        expect(optimized).toEqual([{ start: 1, end: 8 }]);\n      });\n\n      it('merges adjacent ranges', () => {\n        const ranges = [{ start: 1, end: 5 }, { start: 6, end: 10 }];\n        const optimized = optimizePageRanges(ranges);\n        \n        expect(optimized).toEqual([{ start: 1, end: 10 }]);\n      });\n\n      it('keeps separate ranges intact', () => {\n        const ranges = [{ start: 1, end: 5 }, { start: 8, end: 10 }];\n        const optimized = optimizePageRanges(ranges);\n        \n        expect(optimized).toEqual([{ start: 1, end: 5 }, { start: 8, end: 10 }]);\n      });\n\n      it('handles single range', () => {\n        const ranges = [{ start: 1, end: 5 }];\n        const optimized = optimizePageRanges(ranges);\n        \n        expect(optimized).toEqual([{ start: 1, end: 5 }]);\n      });\n\n      it('handles empty array', () => {\n        const optimized = optimizePageRanges([]);\n        expect(optimized).toEqual([]);\n      });\n    });\n\n    describe('formatPageRanges', () => {\n      it('formats single pages', () => {\n        const ranges = [{ start: 1, end: 1 }, { start: 5, end: 5 }];\n        expect(formatPageRanges(ranges)).toBe('1, 5');\n      });\n\n      it('formats ranges', () => {\n        const ranges = [{ start: 1, end: 5 }, { start: 8, end: 10 }];\n        expect(formatPageRanges(ranges)).toBe('1-5, 8-10');\n      });\n\n      it('formats mixed single pages and ranges', () => {\n        const ranges = [{ start: 1, end: 5 }, { start: 8, end: 8 }, { start: 10, end: 12 }];\n        expect(formatPageRanges(ranges)).toBe('1-5, 8, 10-12');\n      });\n\n      it('returns empty string for empty array', () => {\n        expect(formatPageRanges([])).toBe('');\n      });\n    });\n  });\n\n  describe('File Management Utilities', () => {\n    const mockPdfFile = new File(['pdf content'], 'test.pdf', { type: 'application/pdf' });\n    const mockTextFile = new File(['text content'], 'test.txt', { type: 'text/plain' });\n    const mockLargeFile = new File(['x'.repeat(101 * 1024 * 1024)], 'large.pdf', { type: 'application/pdf' });\n    const mockEmptyFile = new File([], 'empty.pdf', { type: 'application/pdf' });\n\n    describe('validateMergeFiles', () => {\n      it('validates correct PDF files', () => {\n        const files = [mockPdfFile];\n        const validation = validateMergeFiles(files);\n        \n        expect(validation[0].isValid).toBe(true);\n        expect(validation[0].error).toBeUndefined();\n      });\n\n      it('rejects non-PDF files', () => {\n        const files = [mockTextFile];\n        const validation = validateMergeFiles(files);\n        \n        expect(validation[0].isValid).toBe(false);\n        expect(validation[0].error).toBe('Only PDF files are supported');\n      });\n\n      it('rejects files exceeding size limit', () => {\n        Object.defineProperty(mockLargeFile, 'size', { value: 101 * 1024 * 1024 });\n        const files = [mockLargeFile];\n        const validation = validateMergeFiles(files);\n        \n        expect(validation[0].isValid).toBe(false);\n        expect(validation[0].error).toBe('File size exceeds 100MB limit');\n      });\n\n      it('rejects empty files', () => {\n        const files = [mockEmptyFile];\n        const validation = validateMergeFiles(files);\n        \n        expect(validation[0].isValid).toBe(false);\n        expect(validation[0].error).toBe('File appears to be empty');\n      });\n    });\n\n    describe('calculateMergeSize', () => {\n      it('calculates total size of files', () => {\n        const files = [\n          new File(['content1'], 'file1.pdf', { type: 'application/pdf' }),\n          new File(['content2'], 'file2.pdf', { type: 'application/pdf' })\n        ];\n        \n        const totalSize = calculateMergeSize(files);\n        expect(totalSize).toBe(16); // 8 + 8 bytes\n      });\n\n      it('returns 0 for empty array', () => {\n        expect(calculateMergeSize([])).toBe(0);\n      });\n    });\n\n    describe('generateMergePreview', () => {\n      it('generates preview data', () => {\n        const files = [mockPdfFile, mockPdfFile];\n        const preview = generateMergePreview(files);\n        \n        expect(preview.fileCount).toBe(2);\n        expect(preview.totalSize).toBeGreaterThan(0);\n        expect(preview.estimatedPages).toBe(20); // 2 files * 10 pages\n        expect(preview.estimatedProcessingTime).toBe(4); // 2 files * 2 seconds\n      });\n\n      it('detects non-PDF files in warnings', () => {\n        const files = [mockPdfFile, mockTextFile];\n        const preview = generateMergePreview(files);\n        \n        expect(preview.compatibilityWarnings).toContain('Some files are not PDFs and will be skipped');\n      });\n    });\n\n    describe('optimizeFileOrder', () => {\n      it('sorts files by name', () => {\n        const file1 = new File([], 'z.pdf', { type: 'application/pdf' });\n        const file2 = new File([], 'a.pdf', { type: 'application/pdf' });\n        const file3 = new File([], 'm.pdf', { type: 'application/pdf' });\n        \n        const optimized = optimizeFileOrder([file1, file2, file3]);\n        \n        expect(optimized[0].name).toBe('a.pdf');\n        expect(optimized[1].name).toBe('m.pdf');\n        expect(optimized[2].name).toBe('z.pdf');\n      });\n    });\n  });\n\n  describe('Extraction Utilities', () => {\n    const mockDocument: PDFDocument = {\n      id: 'doc-1',\n      fileName: 'test.pdf',\n      originalName: 'test.pdf',\n      fileSize: 1000000,\n      pageCount: 10,\n      uploadedAt: '2023-01-01T00:00:00Z',\n      sessionId: 'session-1',\n      mimeType: 'application/pdf',\n      status: 'ready',\n      processingHistory: []\n    };\n\n    describe('assessExtractionCapabilities', () => {\n      it('provides reasonable capabilities for document', () => {\n        const capabilities = assessExtractionCapabilities(mockDocument);\n        \n        expect(typeof capabilities.hasTextLayer).toBe('boolean');\n        expect(typeof capabilities.imageCount).toBe('number');\n        expect(typeof capabilities.tableCount).toBe('number');\n        expect(typeof capabilities.formFieldCount).toBe('number');\n        expect(typeof capabilities.textLength).toBe('number');\n        expect(typeof capabilities.hasBookmarks).toBe('boolean');\n        expect(typeof capabilities.isScanned).toBe('boolean');\n      });\n\n      it('handles null document', () => {\n        const capabilities = assessExtractionCapabilities(null);\n        \n        expect(capabilities.hasTextLayer).toBe(false);\n        expect(capabilities.imageCount).toBe(0);\n        expect(capabilities.tableCount).toBe(0);\n        expect(capabilities.formFieldCount).toBe(0);\n        expect(capabilities.textLength).toBe(0);\n        expect(capabilities.hasBookmarks).toBe(false);\n        expect(capabilities.isScanned).toBe(true);\n      });\n    });\n\n    describe('estimateExtractionSize', () => {\n      it('estimates size based on extraction types', () => {\n        const textSize = estimateExtractionSize(mockDocument, ['text']);\n        const imageSize = estimateExtractionSize(mockDocument, ['images']);\n        const allSize = estimateExtractionSize(mockDocument, ['text', 'images', 'tables', 'metadata', 'forms']);\n        \n        expect(textSize).toBeGreaterThan(0);\n        expect(imageSize).toBeGreaterThan(textSize); // Images should be larger\n        expect(allSize).toBeGreaterThan(imageSize); // All types should be largest\n      });\n\n      it('returns 0 for null document', () => {\n        const size = estimateExtractionSize(null, ['text']);\n        expect(size).toBe(0);\n      });\n    });\n\n    describe('validateExtractionParams', () => {\n      const validParams: ExtractionFormData = {\n        types: ['text', 'images'],\n        formats: {\n          text: 'plain',\n          images: 'png',\n          tables: 'csv',\n          metadata: 'json'\n        },\n        page_range: { start: 1, end: 10 },\n        options: {\n          image_dpi: 300,\n          table_detection_sensitivity: 'medium',\n          ocr_confidence_threshold: 0.8,\n          preserve_formatting: true,\n          include_coordinates: false\n        }\n      };\n\n      it('validates correct parameters', () => {\n        const result = validateExtractionParams(validParams);\n        \n        expect(result.isValid).toBe(true);\n        expect(result.errors).toHaveLength(0);\n      });\n\n      it('requires at least one extraction type', () => {\n        const params = { ...validParams, types: [] };\n        const result = validateExtractionParams(params);\n        \n        expect(result.isValid).toBe(false);\n        expect(result.errors[0]).toContain('At least one extraction type');\n      });\n\n      it('validates page range', () => {\n        const params = { ...validParams, page_range: { start: 10, end: 5 } };\n        const result = validateExtractionParams(params);\n        \n        expect(result.isValid).toBe(false);\n        expect(result.errors[0]).toContain('Start page cannot be greater than end page');\n      });\n\n      it('warns about DPI outside optimal range', () => {\n        const params = { ...validParams, options: { ...validParams.options, image_dpi: 50 } };\n        const result = validateExtractionParams(params);\n        \n        expect(result.isValid).toBe(true);\n        expect(result.warnings?.[0]).toContain('Image DPI should be between 72 and 600');\n      });\n\n      it('validates OCR confidence threshold', () => {\n        const params = { ...validParams, options: { ...validParams.options, ocr_confidence_threshold: 2.0 } };\n        const result = validateExtractionParams(params);\n        \n        expect(result.isValid).toBe(false);\n        expect(result.errors[0]).toContain('OCR confidence threshold must be between 0 and 1');\n      });\n    });\n\n    describe('formatExtractionResults', () => {\n      it('formats extraction results', () => {\n        const results: ExtractedData = {\n          text_content: { plain: 'Sample text' },\n          images: [{\n            id: 'img-1',\n            page_number: 1,\n            bounding_box: { x: 0, y: 0, width: 100, height: 100 },\n            format: 'png',\n            width: 100,\n            height: 100\n          }],\n          tables: [{\n            id: 'table-1',\n            page_number: 1,\n            bounding_box: { x: 0, y: 0, width: 200, height: 100 },\n            rows: 3,\n            columns: 2,\n            confidence: 0.9\n          }],\n          forms: [{\n            id: 'form-1',\n            pageNumber: 1,\n            fields: []\n          }],\n          metadata: { title: 'Test Document' },\n          total_size: 5000,\n          processing_time: 2500\n        };\n        \n        const formatted = formatExtractionResults(results);\n        \n        expect(formatted.summary.textExtracted).toBe(true);\n        expect(formatted.summary.imagesFound).toBe(1);\n        expect(formatted.summary.tablesFound).toBe(1);\n        expect(formatted.summary.formsFound).toBe(1);\n        expect(formatted.summary.metadataExtracted).toBe(true);\n        expect(formatted.totalSize).toBe(5000);\n        expect(formatted.processingTime).toBe(2500);\n      });\n    });\n  });\n\n  describe('Operation Progress Utilities', () => {\n    const mockJob: ProcessingJobWithResults = {\n      id: 'job-1',\n      documentId: 'doc-1',\n      operation: 'splitting',\n      status: 'running',\n      progress: 50,\n      currentStep: 'Processing pages',\n      totalSteps: 3,\n      startedAt: '2023-01-01T00:00:00Z',\n      current_step: 'Processing pages'\n    };\n\n    describe('calculateOperationProgress', () => {\n      it('extracts progress information', () => {\n        const progress = calculateOperationProgress(mockJob);\n        \n        expect(progress.percentage).toBe(50);\n        expect(progress.currentStep).toBe('Processing pages');\n      });\n\n      it('prefers current_step over currentStep', () => {\n        const jobWithCurrentStep = { ...mockJob, current_step: 'New step' };\n        const progress = calculateOperationProgress(jobWithCurrentStep);\n        \n        expect(progress.currentStep).toBe('New step');\n      });\n    });\n\n    describe('estimateCompletionTime', () => {\n      it('estimates completion time based on progress', () => {\n        const jobStartTime = new Date(Date.now() - 10000); // Started 10 seconds ago\n        const jobWithTime = { ...mockJob, startedAt: jobStartTime.toISOString() };\n        \n        const estimatedTime = estimateCompletionTime(jobWithTime);\n        \n        expect(estimatedTime).toBeGreaterThan(0);\n      });\n\n      it('returns 0 for jobs with no progress', () => {\n        const jobWithNoProgress = { ...mockJob, progress: 0 };\n        const estimatedTime = estimateCompletionTime(jobWithNoProgress);\n        \n        expect(estimatedTime).toBe(0);\n      });\n    });\n\n    describe('formatOperationStatus', () => {\n      it('formats different job statuses', () => {\n        expect(formatOperationStatus({ ...mockJob, status: 'pending' }))\n          .toBe('Waiting to start...');\n        \n        expect(formatOperationStatus({ ...mockJob, status: 'running' }))\n          .toBe('Processing pages');\n        \n        expect(formatOperationStatus({ ...mockJob, status: 'completed' }))\n          .toBe('Completed successfully');\n        \n        expect(formatOperationStatus({ ...mockJob, status: 'failed', errorMessage: 'Error occurred' }))\n          .toBe('Error occurred');\n        \n        expect(formatOperationStatus({ ...mockJob, status: 'cancelled' }))\n          .toBe('Operation cancelled');\n      });\n    });\n\n    describe('generateOperationSummary', () => {\n      it('generates operation summary', () => {\n        const result = {\n          operationType: 'splitting',\n          startTime: 1000,\n          endTime: 5000,\n          inputFiles: 1,\n          outputFiles: 3,\n          totalSize: 1500000,\n          success: true\n        };\n        \n        const summary = generateOperationSummary(result);\n        \n        expect(summary.operationType).toBe('splitting');\n        expect(summary.startTime).toBe(1000);\n        expect(summary.endTime).toBe(5000);\n        expect(summary.inputFiles).toBe(1);\n        expect(summary.outputFiles).toBe(3);\n        expect(summary.totalSize).toBe(1500000);\n        expect(summary.success).toBe(true);\n      });\n    });\n  });\n\n  describe('Validation Utilities', () => {\n    describe('validateOperationLimits', () => {\n      it('validates splitting operation (no specific limits)', () => {\n        const result = validateOperationLimits('splitting', {});\n        expect(result.isValid).toBe(true);\n      });\n\n      it('validates merging file count limit', () => {\n        const files = Array.from({ length: 101 }, (_, i) => ({ name: `file${i}.pdf` }));\n        const result = validateOperationLimits('merging', { files });\n        \n        expect(result.isValid).toBe(false);\n        expect(result.errors[0]).toContain('Maximum 100 files');\n      });\n\n      it('validates merging size limit', () => {\n        const files = [{ size: 101 * 1024 * 1024 }]; // 101MB\n        // Mock calculateMergeSize to return large size\n        const result = validateOperationLimits('merging', { files });\n        \n        // This would need calculateMergeSize to be mocked\n        expect(result.isValid).toBe(false);\n        expect(result.errors[0]).toContain('cannot exceed 100MB');\n      });\n\n      it('validates extraction requires types', () => {\n        const result = validateOperationLimits('extraction', { types: [] });\n        \n        expect(result.isValid).toBe(false);\n        expect(result.errors[0]).toContain('At least one extraction type');\n      });\n    });\n\n    describe('checkOperationCompatibility', () => {\n      const mockDoc: PDFDocument = {\n        id: 'doc-1',\n        fileName: 'test.pdf',\n        originalName: 'test.pdf',\n        fileSize: 1000,\n        pageCount: 10,\n        uploadedAt: '2023-01-01',\n        sessionId: 'session-1',\n        mimeType: 'application/pdf',\n        status: 'ready',\n        processingHistory: []\n      };\n\n      it('checks splitting compatibility', () => {\n        expect(checkOperationCompatibility(mockDoc, 'splitting')).toBe(true);\n        \n        const singlePageDoc = { ...mockDoc, pageCount: 1 };\n        expect(checkOperationCompatibility(singlePageDoc, 'splitting')).toBe(false);\n      });\n\n      it('checks merging compatibility (always true)', () => {\n        expect(checkOperationCompatibility(mockDoc, 'merging')).toBe(true);\n        expect(checkOperationCompatibility(null, 'merging')).toBe(false);\n      });\n\n      it('checks extraction compatibility', () => {\n        expect(checkOperationCompatibility(mockDoc, 'extraction')).toBe(true);\n        \n        const emptyDoc = { ...mockDoc, pageCount: 0 };\n        expect(checkOperationCompatibility(emptyDoc, 'extraction')).toBe(false);\n      });\n\n      it('returns false for unsupported operations', () => {\n        expect(checkOperationCompatibility(mockDoc, 'unsupported')).toBe(false);\n      });\n    });\n\n    describe('sanitizeOperationParams', () => {\n      it('removes function properties', () => {\n        const params = {\n          name: 'test',\n          callback: () => {},\n          value: 42\n        };\n        \n        const sanitized = sanitizeOperationParams(params);\n        \n        expect(sanitized.name).toBe('test');\n        expect(sanitized.value).toBe(42);\n        expect(sanitized.callback).toBeUndefined();\n      });\n\n      it('trims string values', () => {\n        const params = {\n          name: '  test  ',\n          description: '\\tDescription\\n'\n        };\n        \n        const sanitized = sanitizeOperationParams(params);\n        \n        expect(sanitized.name).toBe('test');\n        expect(sanitized.description).toBe('Description');\n      });\n    });\n\n    describe('generateValidationMessages', () => {\n      it('generates specific messages for known error codes', () => {\n        const errors = [\n          { code: 'INVALID_PAGE_RANGE', message: '1-100 invalid', field: 'pageRange' },\n          { code: 'FILE_TOO_LARGE', message: '150MB', field: 'file' },\n          { code: 'INVALID_FILE_TYPE', message: 'text/plain', field: 'fileType' },\n          { code: 'MISSING_REQUIRED_PARAM', message: 'Required', field: 'searchTerms' },\n          { code: 'UNKNOWN_ERROR', message: 'Something went wrong', field: undefined }\n        ];\n        \n        const messages = generateValidationMessages(errors);\n        \n        expect(messages[0]).toBe('Invalid page range: 1-100 invalid');\n        expect(messages[1]).toBe('File is too large: 150MB');\n        expect(messages[2]).toBe('Invalid file type: text/plain');\n        expect(messages[3]).toBe('Required parameter missing: searchTerms');\n        expect(messages[4]).toBe('Something went wrong');\n      });\n    });\n  });\n\n  describe('Format Conversion Utilities', () => {\n    describe('formatFileSize', () => {\n      it('formats bytes correctly', () => {\n        expect(formatFileSize(0)).toBe('0 B');\n        expect(formatFileSize(1024)).toBe('1.0 KB');\n        expect(formatFileSize(1048576)).toBe('1.0 MB');\n        expect(formatFileSize(1073741824)).toBe('1.0 GB');\n        expect(formatFileSize(1500)).toBe('1.5 KB');\n        expect(formatFileSize(2500000)).toBe('2.4 MB');\n      });\n    });\n\n    describe('formatProcessingTime', () => {\n      it('formats milliseconds correctly', () => {\n        expect(formatProcessingTime(500)).toBe('500ms');\n        expect(formatProcessingTime(1500)).toBe('1s');\n        expect(formatProcessingTime(65000)).toBe('1m 5s');\n        expect(formatProcessingTime(3665000)).toBe('61m 5s');\n      });\n    });\n\n    describe('generateDownloadFilename', () => {\n      const today = new Date().toISOString().slice(0, 10);\n      \n      it('generates filenames for different operations', () => {\n        expect(generateDownloadFilename('splitting', 'document.pdf'))\n          .toBe(`document_split_${today}.zip`);\n        \n        expect(generateDownloadFilename('merging', 'documents.pdf'))\n          .toBe(`documents_merged_${today}.pdf`);\n        \n        expect(generateDownloadFilename('extraction', 'data.pdf'))\n          .toBe(`data_extracted_${today}.zip`);\n        \n        expect(generateDownloadFilename('redaction', 'sensitive.pdf'))\n          .toBe(`sensitive_redacted_${today}.pdf`);\n        \n        expect(generateDownloadFilename('unknown', 'file.pdf'))\n          .toBe(`file_processed_${today}.pdf`);\n      });\n\n      it('removes .pdf extension from original name', () => {\n        expect(generateDownloadFilename('splitting', 'Document.PDF'))\n          .toBe(`Document_split_${today}.zip`);\n      });\n    });\n  });\n});"