/**\n * @jest-environment jsdom\n */\n\nimport React from 'react';\nimport { render, screen, fireEvent, waitFor } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport { jest } from '@jest/globals';\nimport { MergeInterface } from '../../components/MergeInterface';\nimport { usePDFStore } from '../../store/pdfStore';\nimport * as operationUtils from '../../utils/operationUtils';\n\n// Mock the PDF store\njest.mock('../../store/pdfStore');\nconst mockUsePDFStore = usePDFStore as jest.MockedFunction<typeof usePDFStore>;\n\n// Mock operation utilities\njest.mock('../../utils/operationUtils');\nconst mockValidateMergeFiles = operationUtils.validateMergeFiles as jest.MockedFunction<typeof operationUtils.validateMergeFiles>;\nconst mockCalculateMergeSize = operationUtils.calculateMergeSize as jest.MockedFunction<typeof operationUtils.calculateMergeSize>;\nconst mockGenerateMergePreview = operationUtils.generateMergePreview as jest.MockedFunction<typeof operationUtils.generateMergePreview>;\n\n// Mock child components\njest.mock('../../components/FileUpload', () => {\n  return {\n    __esModule: true,\n    default: ({ onFilesSelected, multiple, accept }: any) => (\n      <div data-testid=\"file-upload\">\n        <input\n          type=\"file\"\n          multiple={multiple}\n          accept={accept}\n          data-testid=\"file-input\"\n          onChange={(e) => {\n            const files = Array.from(e.target.files || []);\n            onFilesSelected(files);\n          }}\n        />\n        <span data-testid=\"multiple\">{multiple ? 'true' : 'false'}</span>\n        <span data-testid=\"accept\">{accept}</span>\n      </div>\n    )\n  };\n});\n\njest.mock('../../components/OperationProgressBar', () => {\n  return {\n    OperationProgressBar: ({ operationType, jobId }: any) => (\n      <div data-testid=\"operation-progress-bar\">\n        <span data-testid=\"operation-type\">{operationType}</span>\n        <span data-testid=\"job-id\">{jobId}</span>\n      </div>\n    )\n  };\n});\n\njest.mock('../../components/ResultPreview', () => {\n  return {\n    ResultPreview: ({ operationType, results }: any) => (\n      <div data-testid=\"result-preview\">\n        <span data-testid=\"operation-type\">{operationType}</span>\n        <span data-testid=\"results\">{JSON.stringify(results)}</span>\n      </div>\n    )\n  };\n});\n\ndescribe('MergeInterface', () => {\n  const mockFile1 = new File(['pdf content 1'], 'test1.pdf', { type: 'application/pdf' });\n  const mockFile2 = new File(['pdf content 2'], 'test2.pdf', { type: 'application/pdf' });\n  const mockInvalidFile = new File(['not pdf'], 'test.txt', { type: 'text/plain' });\n  \n  const defaultStoreState = {\n    merging: {\n      files: [],\n      fileOrder: [],\n      options: {\n        preserve_bookmarks: true,\n        preserve_metadata: true,\n        bookmark_strategy: 'merge_top_level' as const\n      },\n      jobId: undefined,\n      results: undefined\n    },\n    addMergeFiles: jest.fn(),\n    removeMergeFile: jest.fn(),\n    reorderMergeFiles: jest.fn(),\n    setMergeOptions: jest.fn(),\n    initiateMerge: jest.fn()\n  };\n\n  beforeEach(() => {\n    jest.clearAllMocks();\n    mockUsePDFStore.mockReturnValue(defaultStoreState);\n    \n    // Setup default mock implementations\n    mockValidateMergeFiles.mockReturnValue([\n      { isValid: true, size: mockFile1.size },\n      { isValid: true, size: mockFile2.size }\n    ]);\n    \n    mockCalculateMergeSize.mockReturnValue(1000000); // 1MB\n    \n    mockGenerateMergePreview.mockReturnValue({\n      fileCount: 2,\n      totalSize: 1000000,\n      estimatedPages: 20,\n      estimatedProcessingTime: 4,\n      compatibilityWarnings: []\n    });\n  });\n\n  describe('Rendering', () => {\n    it('renders merge interface', () => {\n      render(<MergeInterface />);\n      \n      expect(screen.getByText('Select PDF Files to Merge')).toBeInTheDocument();\n      expect(screen.getByTestId('file-upload')).toBeInTheDocument();\n      expect(screen.getByText('Select multiple PDF files (max 100 files, 100MB total)')).toBeInTheDocument();\n    });\n\n    it('configures file upload for multiple PDF files', () => {\n      render(<MergeInterface />);\n      \n      expect(screen.getByTestId('multiple')).toHaveTextContent('true');\n      expect(screen.getByTestId('accept')).toHaveTextContent('.pdf');\n    });\n\n    it('shows empty state when no files are selected', () => {\n      render(<MergeInterface />);\n      \n      expect(screen.queryByText('Files to Merge')).not.toBeInTheDocument();\n      expect(screen.queryByText('Start Merge')).not.toBeInTheDocument();\n    });\n  });\n\n  describe('File Selection and Management', () => {\n    it('handles file selection', async () => {\n      const user = userEvent.setup();\n      render(<MergeInterface />);\n\n      const fileInput = screen.getByTestId('file-input');\n      \n      // Mock file selection\n      const files = [mockFile1, mockFile2];\n      Object.defineProperty(fileInput, 'files', {\n        value: files,\n        writable: false,\n      });\n      \n      fireEvent.change(fileInput);\n      \n      expect(defaultStoreState.addMergeFiles).toHaveBeenCalledWith(files);\n    });\n\n    it('displays selected files list', () => {\n      mockUsePDFStore.mockReturnValue({\n        ...defaultStoreState,\n        merging: {\n          ...defaultStoreState.merging,\n          files: [mockFile1, mockFile2]\n        }\n      });\n\n      render(<MergeInterface />);\n      \n      expect(screen.getByText('Files to Merge (2)')).toBeInTheDocument();\n      expect(screen.getByText('1. test1.pdf')).toBeInTheDocument();\n      expect(screen.getByText('2. test2.pdf')).toBeInTheDocument();\n    });\n\n    it('shows file validation errors', () => {\n      mockValidateMergeFiles.mockReturnValue([\n        { isValid: false, error: 'Only PDF files are supported', size: mockInvalidFile.size }\n      ]);\n      \n      mockUsePDFStore.mockReturnValue({\n        ...defaultStoreState,\n        merging: {\n          ...defaultStoreState.merging,\n          files: [mockInvalidFile]\n        }\n      });\n\n      render(<MergeInterface />);\n      \n      expect(screen.getByText('Only PDF files are supported')).toBeInTheDocument();\n    });\n\n    it('allows removing files', async () => {\n      const user = userEvent.setup();\n      mockUsePDFStore.mockReturnValue({\n        ...defaultStoreState,\n        merging: {\n          ...defaultStoreState.merging,\n          files: [mockFile1, mockFile2]\n        }\n      });\n\n      render(<MergeInterface />);\n      \n      const removeButtons = screen.getAllByTitle('Remove file');\n      await user.click(removeButtons[0]);\n      \n      expect(defaultStoreState.removeMergeFile).toHaveBeenCalledWith(mockFile1);\n    });\n\n    it('allows reordering files with move up/down buttons', async () => {\n      const user = userEvent.setup();\n      mockUsePDFStore.mockReturnValue({\n        ...defaultStoreState,\n        merging: {\n          ...defaultStoreState.merging,\n          files: [mockFile1, mockFile2]\n        }\n      });\n\n      render(<MergeInterface />);\n      \n      const moveUpButton = screen.getAllByTitle('Move up')[1]; // Second file's move up button\n      await user.click(moveUpButton);\n      \n      // Should reorder files locally and validate\n      expect(mockValidateMergeFiles).toHaveBeenCalled();\n    });\n  });\n\n  describe('Drag and Drop Reordering', () => {\n    it('handles drag start', () => {\n      mockUsePDFStore.mockReturnValue({\n        ...defaultStoreState,\n        merging: {\n          ...defaultStoreState.merging,\n          files: [mockFile1, mockFile2]\n        }\n      });\n\n      render(<MergeInterface />);\n      \n      const fileItems = screen.getAllByText(/test.*\\.pdf/);\n      const firstFile = fileItems[0].closest('.file-item');\n      \n      if (firstFile) {\n        fireEvent.dragStart(firstFile);\n        // Should set dragged index state (not directly testable)\n      }\n    });\n\n    it('handles drop and reorders files', async () => {\n      mockUsePDFStore.mockReturnValue({\n        ...defaultStoreState,\n        merging: {\n          ...defaultStoreState.merging,\n          files: [mockFile1, mockFile2]\n        }\n      });\n\n      render(<MergeInterface />);\n      \n      const fileItems = screen.getAllByText(/test.*\\.pdf/);\n      const firstFile = fileItems[0].closest('.file-item');\n      const secondFile = fileItems[1].closest('.file-item');\n      \n      if (firstFile && secondFile) {\n        // Simulate drag and drop\n        fireEvent.dragStart(firstFile);\n        fireEvent.dragOver(secondFile);\n        fireEvent.drop(secondFile);\n        \n        expect(mockValidateMergeFiles).toHaveBeenCalled();\n      }\n    });\n  });\n\n  describe('Merge Options', () => {\n    it('toggles preserve metadata option', async () => {\n      const user = userEvent.setup();\n      mockUsePDFStore.mockReturnValue({\n        ...defaultStoreState,\n        merging: {\n          ...defaultStoreState.merging,\n          files: [mockFile1, mockFile2]\n        }\n      });\n\n      render(<MergeInterface />);\n      \n      const checkbox = screen.getByLabelText('Preserve document metadata');\n      expect(checkbox).toBeChecked();\n      \n      await user.click(checkbox);\n      expect(defaultStoreState.setMergeOptions).toHaveBeenCalledWith({\n        preserve_metadata: false\n      });\n    });\n\n    it('toggles preserve bookmarks option', async () => {\n      const user = userEvent.setup();\n      mockUsePDFStore.mockReturnValue({\n        ...defaultStoreState,\n        merging: {\n          ...defaultStoreState.merging,\n          files: [mockFile1, mockFile2]\n        }\n      });\n\n      render(<MergeInterface />);\n      \n      const checkbox = screen.getByLabelText('Preserve bookmarks');\n      expect(checkbox).toBeChecked();\n      \n      await user.click(checkbox);\n      expect(defaultStoreState.setMergeOptions).toHaveBeenCalledWith({\n        preserve_bookmarks: false\n      });\n    });\n\n    it('changes bookmark strategy', async () => {\n      const user = userEvent.setup();\n      mockUsePDFStore.mockReturnValue({\n        ...defaultStoreState,\n        merging: {\n          ...defaultStoreState.merging,\n          files: [mockFile1, mockFile2]\n        }\n      });\n\n      render(<MergeInterface />);\n      \n      const select = screen.getByLabelText('Bookmark Strategy');\n      await user.selectOptions(select, 'preserve_all');\n      \n      expect(defaultStoreState.setMergeOptions).toHaveBeenCalledWith({\n        bookmark_strategy: 'preserve_all'\n      });\n    });\n  });\n\n  describe('Validation and Limits', () => {\n    it('shows validation error for insufficient files', () => {\n      mockUsePDFStore.mockReturnValue({\n        ...defaultStoreState,\n        merging: {\n          ...defaultStoreState.merging,\n          files: [mockFile1]\n        }\n      });\n\n      render(<MergeInterface />);\n      \n      expect(screen.getByText('At least 2 PDF files are required for merging')).toBeInTheDocument();\n    });\n\n    it('shows validation error for file count limit', () => {\n      const manyFiles = Array.from({ length: 101 }, (_, i) => \n        new File(['content'], `file${i}.pdf`, { type: 'application/pdf' })\n      );\n      \n      mockUsePDFStore.mockReturnValue({\n        ...defaultStoreState,\n        merging: {\n          ...defaultStoreState.merging,\n          files: manyFiles\n        }\n      });\n\n      render(<MergeInterface />);\n      \n      expect(screen.getByText('Maximum 100 files can be merged at once')).toBeInTheDocument();\n    });\n\n    it('shows validation error for size limit', () => {\n      mockCalculateMergeSize.mockReturnValue(101 * 1024 * 1024); // 101MB\n      \n      mockUsePDFStore.mockReturnValue({\n        ...defaultStoreState,\n        merging: {\n          ...defaultStoreState.merging,\n          files: [mockFile1, mockFile2]\n        }\n      });\n\n      render(<MergeInterface />);\n      \n      expect(screen.getByText('Total file size cannot exceed 100MB')).toBeInTheDocument();\n    });\n\n    it('shows validation error for invalid files', () => {\n      mockValidateMergeFiles.mockReturnValue([\n        { isValid: true, size: mockFile1.size },\n        { isValid: false, error: 'Invalid file', size: mockInvalidFile.size }\n      ]);\n      \n      mockUsePDFStore.mockReturnValue({\n        ...defaultStoreState,\n        merging: {\n          ...defaultStoreState.merging,\n          files: [mockFile1, mockInvalidFile]\n        }\n      });\n\n      render(<MergeInterface />);\n      \n      expect(screen.getByText('1 invalid file(s) found')).toBeInTheDocument();\n    });\n  });\n\n  describe('Merge Preview', () => {\n    it('generates and displays merge preview', () => {\n      mockUsePDFStore.mockReturnValue({\n        ...defaultStoreState,\n        merging: {\n          ...defaultStoreState.merging,\n          files: [mockFile1, mockFile2]\n        }\n      });\n\n      render(<MergeInterface />);\n      \n      expect(screen.getByText('Merge Preview')).toBeInTheDocument();\n      expect(screen.getByText('2')).toBeInTheDocument(); // Files to merge\n      expect(screen.getByText('20')).toBeInTheDocument(); // Total pages\n      expect(screen.getByText('977 KB')).toBeInTheDocument(); // Estimated size (1MB)\n      expect(screen.getByText('merge top level')).toBeInTheDocument(); // Bookmark strategy\n    });\n\n    it('updates preview when files change', () => {\n      mockGenerateMergePreview.mockReturnValue({\n        fileCount: 3,\n        totalSize: 2000000,\n        estimatedPages: 30,\n        estimatedProcessingTime: 6,\n        compatibilityWarnings: []\n      });\n      \n      const threeFiles = [mockFile1, mockFile2, new File(['content 3'], 'test3.pdf', { type: 'application/pdf' })];\n      \n      mockUsePDFStore.mockReturnValue({\n        ...defaultStoreState,\n        merging: {\n          ...defaultStoreState.merging,\n          files: threeFiles\n        }\n      });\n\n      render(<MergeInterface />);\n      \n      expect(mockGenerateMergePreview).toHaveBeenCalledWith(threeFiles);\n      expect(screen.getByText('3')).toBeInTheDocument(); // Updated file count\n    });\n  });\n\n  describe('Merge Initiation', () => {\n    it('initiates merge with valid files', async () => {\n      const user = userEvent.setup();\n      mockUsePDFStore.mockReturnValue({\n        ...defaultStoreState,\n        merging: {\n          ...defaultStoreState.merging,\n          files: [mockFile1, mockFile2]\n        }\n      });\n\n      render(<MergeInterface />);\n      \n      const startButton = screen.getByText('Start Merge');\n      await user.click(startButton);\n      \n      expect(defaultStoreState.initiateMerge).toHaveBeenCalledWith({\n        files: [mockFile1, mockFile2],\n        options: {\n          preserve_bookmarks: true,\n          preserve_metadata: true,\n          bookmark_strategy: 'merge_top_level'\n        }\n      });\n    });\n\n    it('prevents merge when validation errors exist', async () => {\n      mockUsePDFStore.mockReturnValue({\n        ...defaultStoreState,\n        merging: {\n          ...defaultStoreState.merging,\n          files: [mockFile1] // Only one file\n        }\n      });\n\n      render(<MergeInterface />);\n      \n      const startButton = screen.getByText('Start Merge');\n      expect(startButton).toBeDisabled();\n    });\n\n    it('handles merge initiation errors', async () => {\n      defaultStoreState.initiateMerge.mockRejectedValue(new Error('Merge failed'));\n      \n      const user = userEvent.setup();\n      mockUsePDFStore.mockReturnValue({\n        ...defaultStoreState,\n        merging: {\n          ...defaultStoreState.merging,\n          files: [mockFile1, mockFile2]\n        }\n      });\n\n      render(<MergeInterface />);\n      \n      const startButton = screen.getByText('Start Merge');\n      await user.click(startButton);\n      \n      await waitFor(() => {\n        expect(screen.getByText('Failed to start merge operation. Please try again.')).toBeInTheDocument();\n      });\n    });\n  });\n\n  describe('Progress and Results', () => {\n    it('shows progress bar when job is running', () => {\n      mockUsePDFStore.mockReturnValue({\n        ...defaultStoreState,\n        merging: {\n          ...defaultStoreState.merging,\n          jobId: 'merge-job-123'\n        }\n      });\n\n      render(<MergeInterface />);\n      \n      const progressBar = screen.getByTestId('operation-progress-bar');\n      expect(progressBar).toBeInTheDocument();\n      expect(screen.getByTestId('operation-type')).toHaveTextContent('merging');\n      expect(screen.getByTestId('job-id')).toHaveTextContent('merge-job-123');\n    });\n\n    it('shows results when merge is completed', () => {\n      const mockResults = {\n        filename: 'merged.pdf',\n        total_pages: 20,\n        file_size: 1500000\n      };\n\n      mockUsePDFStore.mockReturnValue({\n        ...defaultStoreState,\n        merging: {\n          ...defaultStoreState.merging,\n          results: mockResults\n        }\n      });\n\n      render(<MergeInterface />);\n      \n      const resultPreview = screen.getByTestId('result-preview');\n      expect(resultPreview).toBeInTheDocument();\n      expect(screen.getByTestId('operation-type')).toHaveTextContent('merge');\n    });\n\n    it('calls completion callback when results are available', () => {\n      const mockOnComplete = jest.fn();\n      const mockResults = { filename: 'merged.pdf' };\n\n      mockUsePDFStore.mockReturnValue({\n        ...defaultStoreState,\n        merging: {\n          ...defaultStoreState.merging,\n          results: mockResults\n        }\n      });\n\n      render(<MergeInterface onMergeComplete={mockOnComplete} />);\n      \n      expect(mockOnComplete).toHaveBeenCalledWith(mockResults);\n    });\n  });\n\n  describe('File Information Display', () => {\n    it('shows file size and estimated page count', () => {\n      mockUsePDFStore.mockReturnValue({\n        ...defaultStoreState,\n        merging: {\n          ...defaultStoreState.merging,\n          files: [mockFile1]\n        }\n      });\n\n      render(<MergeInterface />);\n      \n      // Should show file size (mocked file size / 1024)\n      expect(screen.getByText(/KB/)).toBeInTheDocument();\n      expect(screen.getByText(/pages/)).toBeInTheDocument();\n    });\n\n    it('shows drag and drop instructions', () => {\n      mockUsePDFStore.mockReturnValue({\n        ...defaultStoreState,\n        merging: {\n          ...defaultStoreState.merging,\n          files: [mockFile1, mockFile2]\n        }\n      });\n\n      render(<MergeInterface />);\n      \n      expect(screen.getByText('Drag files to reorder • Files will be merged in the order shown')).toBeInTheDocument();\n    });\n  });\n\n  describe('Accessibility', () => {\n    it('has proper ARIA labels and roles', () => {\n      render(<MergeInterface />);\n      \n      expect(screen.getByLabelText(/preserve document metadata/i)).toBeInTheDocument();\n      expect(screen.getByLabelText(/preserve bookmarks/i)).toBeInTheDocument();\n      expect(screen.getByLabelText(/bookmark strategy/i)).toBeInTheDocument();\n    });\n\n    it('provides proper button titles for actions', () => {\n      mockUsePDFStore.mockReturnValue({\n        ...defaultStoreState,\n        merging: {\n          ...defaultStoreState.merging,\n          files: [mockFile1, mockFile2]\n        }\n      });\n\n      render(<MergeInterface />);\n      \n      expect(screen.getAllByTitle('Move up')).toHaveLength(2);\n      expect(screen.getAllByTitle('Move down')).toHaveLength(2);\n      expect(screen.getAllByTitle('Remove file')).toHaveLength(2);\n    });\n  });\n});"